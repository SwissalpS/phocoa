README for the Cocoa-Style PHP Framework (PHOCOA)

Both CLI and HTTP access to functionality is available. In the HTTP environment, everything is bootstrapped automatically, you need only write WFModule subclasses to add request handlers. On the CLI side, there is now an autoload mechanism in place. To bootstrap the PHOCOA environment, you need only include the webapp.conf file at the top of the CLI script. We recommend setting up and ENV PHOCOA_PROJECT_CONF with the absolute path to the webapp.conf file and then using this at the top of all CLI scripts:

require_once $_ENV['PHOCOA_PROJECT_CONF'];

This will bootstrap the web application, load the application delegate, etc. PHOCOA's autoload mechanism will then call into your app to allow you to provide autoloading for your systems.

?? Eventually this could be wrapped in a phing script that figures out the current project and automatically sets this ENV and calls your script.

-------------------------------

Dependencies
1) PHP5
2) Propel is nice (http://propel.phpdb.org)
3) Pear Packages
- Mail
- Mail_Mime
4) Phing


TODO

1.0 Milestone:
- Remove need for httpd.conf - by default allow /index.php/invPath.
- WFRequestControllerDelegate -> has callbacks to process paths before default option; allows people to implement URI mapping, pre-processing, error handlers (404) etc
  -> Add WFRequestControllerException system; 404, 302, etc by throwing exceptions. 
- Figure out a way to implement .ibpalette type functionality
  -> Creating widget bundles that are drop-in compatible
  -> Figure out better way for re-using modules so that they can be used as widgets of other pages: tricky life-cycle consequences
  -> Basic idea that pages and views are handled the same way.
- (DONE) prototypes for the WFDynamic controls so you can "configure" the default setup for a widget in a table, matrix, etc
- I18N infrastructure -> Like Cocoa; WFLocalizedStringForString:
- Improve bindings support:
    - (DONE) Read only...
    - (DONE) Single Value Binding (currently what we do)
    - (DONE) Multi-Value Bindings (automatically read-only)
        - (DONE) Boolean: enabled && enabled2 && enabled3, OR hidden || hidden2 || hidden3
        - (DONE) Pattern: Ability to craft strings together from multiple values, a la formatstring: value="#%1% of %2% selected." The formatstring is set in the binding option "ValuePattern".
        - (NA) Argument: for target-action: can call a selector with multiple arguments (not required b/c our actions don't currently accept any arguments)
- (DONE) Array operators: http://developer.apple.com/documentation/Cocoa/Conceptual/KeyValueCoding/Concepts/ArrayOperators.html
- Make sure that the "page life cycle" is working most effectively. I am not positive I am happy with the order that things occur. This is mostly because of WFDynamic and the need to call createWidgets() over again?
- Move .config and .instances files to YAML to improve compatibility for people managing with text files and make other GUI editors easier to write.
- Improve 'default' template to a nice-looking one based on UberTemplate.
- (DONE) Skins should be attached to the root invocation, not to the request. This way one can access the skin for the current module rather than only for the "current request".
- (DONE) Need to make "skin" available from page. For things like email and sub-modules the "skin" desired is different, but widgets and such need to be able to add to "head" element etc. Figure something out for that.
- Deprecate SKIN_WRAPPER_TYPE_* in favor of WFSkin::SKIN_WRAPPER_TYPE_*

WFState -- idea for a simple widget to help stuff state in a form. Would simply serialize passed data and put it into a hidden var... and restore state! with bindings!
WFTabView -- rename to WFTabbedFormPanel? It must be in a form, and uses restoreState() from WFWidget, so this would make sense... also, remove "non-onepage" mode as we'll use a WFTabbedNavigationView for that.

WFSession - still needs to be designed. The current design sucks.

The page cycle is still really tricky... look at this further... ideas:
1) Do we need a callback for "noaction?" or is "if ($page->hasSubmittedForm())" good enough inside of _PageDidLoad?
2) Do we need more hooks? Do things happen in the right order? The way things are created, restored, etc, seems fragile. Lots of hacking occuring to make it work.

ARCHITECTURAL THINGS TO INVESTIGATE
Use of FilterIterator as predicate searching.

DOCUMENTATION:: API GUIDE:: SELF-DOCUMENTING CODE WIHT PHPDOCUMENTOR
We use PHPDOC (included in Pear) to document the code: http://manual.phpdoc.org/HTMLframesConverter/default/

Each file should have the following at the top:

/* vim: set expandtab tabstop=4 shiftwidth=4: */
/**
 * @package KeyValueCoding
 * @subpackage Bindings
 * @copyright Copyright (c) 2005 Alan Pinstein. All Rights Reserved.
 * @version $Id: kvcoding.php,v 1.3 2004/12/12 02:44:09 alanpinstein Exp $
 * @author Alan Pinstein <apinstein@mac.com>                        
 */

The Package should be the section of the framework that you're working on. The default is framework-base, so use that if it's something basic.
Here are the top-level packages so far (no spaces allowed)
framework-base
KeyValueCoding
UI
WebApplication

Subpackages are just for useful navigation within the packages. Do what makes sense, but start with Captial SubPackage Names!

DOCUMENTATION:: USER GUIDE:: DOCBOOK
DocBook Format. See http://opensource.bureau-cornavin.com/crash-course/ or http://www.docbook.org/tdg5/en/html/docbook.html
Edit with XMLMind's XXE WYSIWYG Editor.

BUILD SYSTEM:
Phing. Idea is to use Phing to do everything in the system from initial setup of a new framework-based web application to showing bindings info to creating .instances files from .tpl files.

CONVENTIONS

CLASS NAMES
WF<ClassName>

WF = "Web Framework"

FUNCTION NAMING - use title case, start with lowercase
sampleFunctionName()

This naming convention is purposely different from the php naming convention so that you can easily tell the difference between framework functions and php functions.

INTERFACES / PROTOCOLS
Our web framework uses many techniques similar to Apple's Cocoa environment. One of the is the use of PROTOCOLS, both FORMAL and INFORMAL. In PHP, the FORMAL protocols are defined / implemented as PHP5 interfaces. INFORMAL protocols (protocols where not ALL methods must be implemented, common for delegates) are defined as PHP interfaces, but in implemention, you only add the methods, you do not do "implements WFBlahProtocol".

Informal protocols for delegates are typically defined (basically for documentation purposes) as PHP classes ending in Delegate. For instance, WFWebApplicationDelegate.

INCLUDES
All script files should start with:

require_once '../relative-path-to/conf/webapp.conf';

This one include will set up the PHP include_path so that all remaining includes can be done as relative to the root directory of the project. This is true for CLI scripts as well.

----------------------------------

Generating tags files from the source: (BTW these are all good candiates for the PHING build system!)
cd to webframework
ctags -R

Generating PHPDoc
cd to webframework
phpdoc -dn framework-base -t docs/phpdocs -ti "PHOCOA Documentation" -o HTML:frames:default --ignore test/ -d framework -f "smarty/plugins/*" -f "conf/webapp.conf"

PROPEL
To use propel, need to include the PHOCOA code and make Propel's BaseObject.php extend WFObject. Be sure to include via FRAMEWORK_DIR rather than hard-coded so that multiple instances can live on a single server.

ERROR HANDLING
Should we have a WFException class? This class would have the following properties:
- errorActions (LOG, EMAIL)
- severity (WARN, FATAL)
Methods:
handleException($e)
  if LOG, LOG error
  if EMAIL, email error
  if FATAL, display error and halt execution
    - display error on development, display nice page on production
  if WARNING, procede (of course client can re-throw)

** maybe the LOG/EMAIL thing should be a site-wide config?

GENERAL
Convert to PHP5 conventions... enable E_STRICT and clean up everything!

USERLAND
For several things need a userland solution so that framework can be updated independently and harmlessly from main application.
--> templates (ie errors, dynamic smarty template, page not found, etc)
--> modules (maybe a contrib directory will include all bundled ones? system will check modules first, then check APP/contrib/modules to allow overriding?)

FRAMEWORK ARCHITECTURE
- Need to decide about full-path-widget-ids (ie myForm.name vs name so we can have form-based namespaces) NO just make them all unique.

LIST OF DIFFERENCES FROM COCOA, for helping people who know Cocoa.
1) NSControl / NSCell - These are used heavily in Cocoa to handle the UI. All NSControls are NSView subclasses, which adds lots of overhead. Cocoa also has NSCell classes which handle a lot of the events and drawing. Since we don't have to deal with complex UI event handling (ie mouse tracking, etc), we have only NSControls for the UI.
2) Bindings - We don't implement KVO (Key-Value Observing) because we aren't a real-time interactive system. HTTP requests and forms essentially "batch" changes and then repaint the entire screen. So instead of having everything real-time, we simply use bindings ONCE on the way in (to restore the WFRequestView) and once on the way out (so the UI controls can "grab" their proper values).

Another reason for this is that Obj-C runtime can intercept calls to setXXX() and trigger observing events. We can't do that from PHP. Delaying the "reading" of bound data until after the code has run allows developers to use setXXX() calls and still have the values reflected in the UI.
NOTE: Examine ArrayAccess interface; this may allow us to detect calls, at least with $obj['propName'] = XXX syntax!
3) WFFormatters. Our formatters are linked in with the same error mechanism as the validators. In Cocoa, the formatters run in a real-time UI environment, and they can literally stop bad data from being entered. For us, they're more of a convenience item for display and validating well-known data types.
