<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<book>
  <title>PHOCOA User Guide</title>

  <chapter>
    <title>Introduction to PHOCOA</title>

    <section>
      <title>Overview</title>

      <para>PHOCOA is an object-oriented, event-driven, componentized, MVC
      (model-view-controller) web application framework based on Apple's Cocoa
      architecture.</para>

      <para>PHOCOA's primary intent is to make developing web applications in
      PHP easier, faster, and with fewer bugs. The framework handles most of
      the "dirty work" of programming by removing the need to write much glue
      code for data binding (moving data between the model layer and view
      layer of your application), validation, error handling, request
      processing, etc. Most of your time will be spent designing your GUI and
      writing application-specific logic rather than dealing with form data,
      database calls, etc.</para>
    </section>

    <section>
      <title>External Technologies</title>

      <para>PHOCOA relies on several technologies to work its magic:</para>

      <itemizedlist>
        <listitem>
          <para>PHP 5 - programming language</para>
        </listitem>

        <listitem>
          <para>Smarty - user interface / presentation layer</para>
        </listitem>

        <listitem>
          <para>Propel - database abstraction / model layer</para>
        </listitem>
      </itemizedlist>

      <para>PHOCOA itself provides the controller layer of the MVC
      architecture.</para>
    </section>

    <section>
      <title>PHOCOA Technologies</title>

      <para>PHOCOA itself contributes several technologies to the
      framework.</para>

      <itemizedlist>
        <listitem>
          <para>Request Controller - handles automatically handing off web
          requests to various custom "modules" that will implement the
          application's logic.</para>
        </listitem>

        <listitem>
          <para>Page Controller - handles initializing, displaying, and
          maintaining state of UI objects.</para>
        </listitem>

        <listitem>
          <para>Bindings - provides the ability to "bind" UI objects to data
          objects and thereby elimintate the need to write glue code to move
          data between the model and the view layers.</para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter>
    <title>Motivation</title>

    <section>
      <title>Classic Problems of Web Development, and How PHOCOA Solves
      Them</title>

      <para>Developing web applications presents a variety of challenges.
      Listed below are a number of classic web development architectural
      problems, and how PHOCOA provides solutions.</para>

      <itemizedlist>
        <listitem>
          <para>Separation of Data, Presentation, and Glue layers of the
          code.</para>

          <para>Presentation templates should be clearly separated from other
          code, allowing designers to easily edit the look and feel without
          breaking the appilcation or dealing with business logic.</para>

          <para>Data model code should represent only the pure data model of
          your system, and have no code related to UI.</para>

          <para>Glue code links the model layer to the view layer. Glue code
          is typically the code for each "web page". It loads up the right
          data and view pieces for that page, and links the two
          together.</para>

          <para><emphasis>This problem is typically solved with a MVC
          design.</emphasis></para>

          <para>PHOCOA uses a MVC architecture as part of its
          framework.</para>

          <para>PHOCOA has some flexibility in the model layer, but we
          recommend Propel for model objects that are stored in an RDBMS. Of
          course, not all of your model objects will be persisted, and you can
          write your own classes as well. You can use other persistence
          solutions as well, but this may break some of the functionality of
          the framework.</para>

          <para>For the presentation layer, PHOCOA uses a template system to
          separate the presentation layer from the Model and Controller
          layers. PHOCOA uses the Smarty template engine, but it is possible
          that the system could be extended to use other template
          engines.</para>

          <para>PHOCOA's controller layer is one of the most powerful parts of
          the framework. The PHOCOA controller layer provides automatic
          state-maintenance of form data, a formalized data validation
          mechanism, and a bindings layer. All of these items will be
          discussed in more detail below, but have the net effect of
          drastically reducing the amount of code you have to write.</para>
        </listitem>

        <listitem>
          <para>Persistence / Retrieval of Model objects to a database.</para>

          <para>Model objects should be accessible through a single interface
          and easily retrieved and persisted. Typically this means saving
          complex relational model data in a RDBMS, as well as querying the DB
          and restoring model state.</para>

          <para><emphasis>This problem is typically solved by
          Object-Relational mapping tools.</emphasis></para>

          <para>PHOCOA currently uses a modified version of Propel to provide
          object persistence. The modification that is made is simply to make
          the Propel BaseObject subclass the PHOCOA framework's base object,
          WFObject. This allows Propel objects to provide the requisite
          interfaces for integrating with PHOCOA.</para>
        </listitem>

        <listitem>
          <para>"Skinning" - having an overall look and feel for a site that
          is easily switched out. Also, having different look &amp; feel for
          different parts of a site. Also, getting data into the HEAD section
          of the page.</para>

          <para>All web sites have graphics that are used for every page. We
          call this a "skin". Some sites allow different themes of a single
          skin, and others use different skins for different parts of the
          site.</para>

          <para><emphasis>This problem is typically solved with include files
          and logic to switch between files.</emphasis></para>

          <para>PHOCOA has a complete infrastructure for skinning built into
          the framework. A web application can have an unlimited number of
          skin setups for different parts of the site. Additionally, each of
          these skin setups can have an unlimited number of skins with an
          unlimited number of sub-themes. Skins in PHOCOA are completely
          arbitrary and impose absolutely no design restrictions.</para>

          <para>The undlerlying skin mechanism also allows you to easily
          customize HEAD information such as title and meta tags.</para>

          <para>PHOCOA also includes a menu system infrastructure for managing
          hierachical menu systems.</para>
        </listitem>

        <listitem>
          <para>Maintaining State of a Form Between Requests.</para>

          <para>A nice web application will keep track of all of the data the
          user has entered into the form. In the case that the form's action
          cannot be completed due to validation or other error, the form will
          need to be re-displayed, and it sure is nice if it looks the same as
          when the user pressed "Submit".</para>

          <para><emphasis>This problem is typically solved by a lot of glue
          code, or with tools like HTML_QuickForm or
          patForms.</emphasis></para>

          <para>PHOCOA provides a complete UI state-maintainance mechanism. A
          full set of widgets are provided that represent all HTML input
          types. Each widget automatically maintains its own state. It is also
          possible to create custom widgets to promote re-use of complex
          widgets such as color pickers, date pickers, etc.</para>
        </listitem>

        <listitem>
          <para>Centralized Dispatch Architecture</para>

          <para>Web applications typically have many "actions" that can be
          performed by the user. Developers need a way to easily determine
          which action was requested, and a way to dispatch this action to the
          correct handler.</para>

          <para><emphasis>This problem is typically solved with a Front
          Controller pattern.</emphasis></para>

          <para>PHOCOA implements a Front Controller that locates "modules" in
          unlimited folder structure. PHOCOA also allows your modules to
          access PATH INFO data to promote friendly-URL use.</para>

          <para>PHOCOA is an event-driven architecture as well, automatically
          dispatching control to your action handlers in response to FORM
          submissions.</para>
        </listitem>

        <listitem>
          <para>Request Variable Normalization</para>

          <para>Web applications should take care to prevent XSS (cross-site
          scripting) attacks caused by user manipulation of the request
          data.</para>

          <para><emphasis>This problem is typically solved by writing code to
          filter all incoming data to make sure that it's valid and
          meaningful.</emphasis></para>

          <para>PHOCOA's UI state management only responds to manifested FORM
          parameters, reducing XSS attacks.</para>
        </listitem>

        <listitem>
          <para>Data Validation and Normalization</para>

          <para>Data input to a web application, whether via Path Info or Form
          Submission, needs to be propagated to the model and validated.
          Ideally, you should be able to detect multiple problems at the same
          time to make the site easier to use. At some poin the data must also
          be normalized. The errors must then of course be shown to the
          user.</para>

          <para><emphasis>This problem is typically solved by a number of
          methods: pre-validating data, integrated validation code in model
          components, etc.</emphasis></para>

          <para>PHOCOA provides a complete solution for data validation and
          normalization. A concept called Key-Value Coding provides a common
          infrastructure for writing validation methods on any object.
          Normalization of the data occurs inside the validator. Beyond that,
          the PHOCOA infrastructure provides a centralized location to track
          all errors in a single request. PHOCOA also provides an easy way to
          display these errors in the UI. You can list all errors as well as
          errors for each individual widget.</para>
        </listitem>

        <listitem>
          <para>Web Application Configuration and Deployment</para>

          <para>There are many settings that are application-wide and need to
          be accessible by all parts of the application. This global data can
          be broken down into two types of data: data that is the same whether
          the application is running on a Production or Development server,
          and data that is always needed globally, but changes based on the
          Production/Development status.</para>

          <para><emphasis>Typically this problem is solved by include
          files.</emphasis></para>

          <para>PHOCOA configuration handles both of these situations.
          Application-specific configuration is typically handled by the
          WFWebApplication object via callbacks, and Deployment-specific
          configuration is handled via a conf file.</para>
        </listitem>

        <listitem>
          <para>Session Management</para>

          <para>Sometimes web applications need to keep state across multiple
          requests that is linked to a user's session.</para>

          <para><emphasis>This problem is typically solved using PHP's Session
          API.</emphasis></para>

          <para>PHOCOA doesn't yet provide any session infrastructure.</para>
        </listitem>

        <listitem>
          <para>User Authorization and Authentication</para>

          <para>Many web sites today have a "login" capability. Users can log
          in to access additional functionality or personalization. While the
          specifics of what a logged in user gets vary greatly among
          applications, they all share the need to perform
          authentication.</para>

          <para><emphasis>This problem is typically solved with a special web
          page to perform authentication, followed by keeping track of the
          user in a session context.</emphasis></para>

          <para>PHOCOA has a simple authorization infrastructure that requires
          implementation of only a few methods to login-enable your
          application. A simple interface allows your back-end application to
          use whatever authentication protocol is appropriate. PHOCOA's
          authorization manager also includes support for "Remember Me"
          functionality.</para>
        </listitem>

        <listitem>
          <para>Component Re-Use and Compositing</para>

          <para>Many web applications have "snippets" of functionality that
          need to be re-used througout the site. Search, login, headlines, are
          often self-contained "portlets" of functionality that should be
          re-usable.</para>

          <para><emphasis>This problem is typically solved via
          includes.</emphasis></para>

          <para>PHOCOA provides a rich compositing architecture. Each module
          you create is automatically re-usable in other modules, or in the
          skin itself. PHOCOA provides a variety of compositing and targeting
          capabilities for ushering users through the site.</para>
        </listitem>

        <listitem>
          <para>Data Pagination</para>

          <para>Pagination is the "chunking" of large data sets into smaller
          portions. This prevents a web page from being infinitely long.
          Pagination also typically includes sorting options for the data
          set.</para>

          <para><emphasis>While many data access layers already have
          pagination support, developers are typically left to handle the UI
          portions of pagination on their own.</emphasis></para>

          <para>PHOCOA provides out-of-the-box support for pagination of PHP
          arrays, Propel Criteria-based data sets, and raw SQL data sets via
          Creole. Propel includes several pagination widgets to aid in the
          display of the paginator navigation, and to help with the process of
          switching pages, sorting, etc.</para>
        </listitem>

        <listitem>
          <para>Clean URLS</para>

          <para>Modern web sites need to have clean, simple URLs (i.e., such
          as www.mydomain.com/products/myProduct) to provide a
          easy-to-remember URLs and be search-engine friendly.</para>

          <para><emphasis>This problem is typically solved by parsing the
          PATH_INFO from a URL into your own data structure, then displaying
          the desired page.</emphasis></para>

          <para>PHOCOA's request parameter system makes it easy declare a
          clean URL interface for any page.</para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter>
    <title>Getting Started With PHOCOA Programming</title>

    <para>PHOCOA has a very large set of technologies. Because it is based on
    Cocoa (Apple's development infrastructure), if you are a Cocoa programmer
    things will make a lot of sense to you. If you are not familar with Cocoa,
    there is a bit of a learning curve. But trust us, it's worth it. The power
    of PHOCOA will allow you to deliver robust web applications with minimal
    coding in record time.</para>

    <para>Instead of starting off by explaining all of the concepts and
    technologies, we will first walk you through a simple application to show
    you how easy the finished product is. You will be much more motivated to
    learn the concepts when you realize how much time PHOCOA can save
    you.</para>

    <para>This chapter will walk you through the development of a simple
    "Hello, World" application that shows off all of the basic concepts. We
    will explain each concept as simlpy as possible for the example.</para>

    <section>
      <title>Installation and Configuration</title>

      <para>The PHOCOA framework is contained in its own directory. Your
      PHOCOA-based web application will live in its own directory, separate
      from the framework code. This makes it easy to keep the two separated
      for purposes of backup, upgrading, etc.</para>

      <bridgehead>PHOCOA Directory Structure</bridgehead>

      <para>First let's install the PHOCOA framework. Unpack the PHOCOA
      tarball. The directory structure looks like:</para>

      <screen>$ ls -l phocoa/
total 0
drwxr-xr-x    4 alanpins staff         136 Aug  2 10:34 classes
drwxr-xr-x    5 alanpins staff         170 Oct 15 16:53 conf
drwxr-xr-x    7 alanpins staff         238 Oct 17 14:57 docs
drwxr-xr-x   34 alanpins staff        1156 Oct 17 13:57 framework
drwxr-xr-x    9 alanpins staff         306 Oct 16 12:04 modules
drwxr-xr-x    6 alanpins staff         204 Oct 15 16:50 phing
drwxr-xr-x    4 alanpins staff         136 Aug  2 10:33 skins
drwxr-xr-x    5 alanpins staff         170 Aug  2 10:33 smarty
drwxr-xr-x    5 alanpins staff         170 Aug  2 10:34 wwwroot</screen>

      <para>The <emphasis>classes</emphasis> directory contains a skeleton of
      the basic application infrastructure needed to have a functional
      application. This will be copied to your application's modules directory
      during install.</para>

      <para>The <emphasis>conf</emphasis> directory contains default versions
      of all configuraiton files. These will be copied to your application's
      conf directory during install.</para>

      <para>The <emphasis>docs</emphasis> directory contains a complete PHPDoc
      API reference for the framework. Once you have PHOCOA installed, this
      can be reached from http://your-server.com/docs.</para>

      <note>
        <para>The docs directory shipped with PHOCOA does not include built
        documentation. Use PHPDOC to build the docs with the following
        command. Eventually, this will be set up as a Phing task. The docs are
        also available online at <ulink
        url="???">http://phocoa.com/docs/</ulink>.</para>

        <screen>$ cd phocoa
$ phpdoc -dn framework-base -t docs/phpdocs -ti "PHOCOA Documentation" -o HTML:frames:default \
--ignore test/ -d framework -f "smarty/plugins/*" -f "conf/webapp.conf"</screen>
      </note>

      <para>The <emphasis>framework</emphasis> directory contains most of the
      framework's code.</para>

      <para>The <emphasis>modules</emphasis> directory contains modules that
      are used by the core framework, or are bundled with the framework. These
      will be copied to your application's modules directory during
      install.</para>

      <para>The <emphasis>phing</emphasis> directory contains the phing
      buildfiles for PHOCOA.</para>

      <para>The <emphasis>skins</emphasis> directory contains bundled skins.
      This is just a single skin, so that your application has some skin when
      it starts. These will be copied to your application's skins directory
      during install.</para>

      <para>The <emphasis>smarty</emphasis> directory is where templates and
      plugins used by the framework go.</para>

      <para>The <emphasis>wwwroot</emphasis> directory is the public wwwroot.
      This wwwroot contains the bootstrapping code for a PHOCOA application
      and a directory for all public www documents. This will be copied to
      your application's wwwroot directory on install.</para>

      <bridgehead>Using Phing to Start a New Project</bridgehead>

      <para>PHOCOA uses Phing to help with managing your web application.
      Let's create a new project.</para>

      <screen>phing -f phocoa/phing/build.xml

Buildfile: /Users/alanpinstein/dev/sandbox/phocoa/phocoa/phing/build.xml

phocoa &gt; prepare:
     [echo] PHOCOA framework base dir at: /Users/alanpinstein/dev/sandbox/phocoa/phocoa/phing/..

phocoa &gt; newproject:
Enter the name of the new project: helloworld
Enter the path to create the new project in: /Users/alanpinstein/dev/sandbox 
Enter the name of the server (ie dns name) that will host this application: [localhost] 
Enter the IP of the server that will host this application: [127.0.0.1] 
Enter the PORT of the server that will host this application: [80] 
     [echo] Creating a template for new project in /Users/alanpinstein/dev/sandbox/helloworld
     [echo] Creating project directories and setting up permissions...
    [mkdir] Created dir: /Users/alanpinstein/dev/sandbox/helloworld
    [mkdir] Created dir: /Users/alanpinstein/dev/sandbox/helloworld/helloworld
    [mkdir] Created dir: /Users/alanpinstein/dev/sandbox/helloworld/log
    [chmod] Changed file mode on '/Users/alanpinstein/dev/sandbox/helloworld/log' to 777
    [mkdir] Created dir: /Users/alanpinstein/dev/sandbox/helloworld/runtime
    [chmod] Changed file mode on '/Users/alanpinstein/dev/sandbox/helloworld/runtime' to 777
    [mkdir] Created dir: /Users/alanpinstein/dev/sandbox/helloworld/runtime/smarty/templates_c
    [chmod] Changed file mode on '/Users/alanpinstein/dev/sandbox/helloworld/runtime/smarty/templates_c' to 777
     [echo] Copying PHOCOA templates...
     [copy] Copying 905 files to /Users/alanpinstein/dev/sandbox/helloworld/helloworld
     [echo] Setting up configuration files...
     [copy] Copying 2 files to /Users/alanpinstein/dev/sandbox/helloworld/helloworld
[filter:ReplaceTokens] Replaced "##SERVER_IP##" with "127.0.0.1"
[filter:ReplaceTokens] Replaced "##SERVER_PORT##" with "80"
[filter:ReplaceTokens] Replaced "##SERVER_NAME##" with "localhost"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_BASE_DIR##" with "/Users/alanpinstein/dev/sandbox/phocoa/phocoa/phing/.."
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_CONTAINER_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_CONTAINER_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_BASE_DIR##" with "/Users/alanpinstein/dev/sandbox/phocoa/phocoa/phing/.."
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_CONTAINER_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_CONTAINER_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld/helloworld"
[phingcall] Calling Buildfile '/Users/alanpinstein/dev/sandbox/phocoa/phocoa/phing/build.xml' with target 'httpdconf'

phocoa &gt; httpdconf:
     [echo] Make sure your httpd.conf file contains the line: Include /Users/alanpinstein/dev/sandbox/helloworld/helloworld/conf/httpd.conf

BUILD FINISHED

Total time: 2 minutes  51.07 seconds
</screen>

      <para>You should now have a directory <emphasis>helloworld</emphasis>
      containing your new PHOCOA application.<emphasis></emphasis></para>

      <screen>$ ls -l helloworld                                                                                                                                           alanpinstein@g5:~/dev/sandbox
total 0
drwxr-xr-x    7 alanpins staff         238 Oct 17 15:03 helloworld
drwxrwxrwx    2 alanpins staff          68 Oct 17 15:02 log
drwxrwxrwx    3 alanpins staff         102 Oct 17 15:02 runtime</screen>

      <para>This directory contains your PHOCOA deployment structure.
      Typically, log and runtime (tmp / cache) files are not part of your
      source code, so PHOCOA sets up a wrapper directory containing these
      items.</para>

      <para>The <emphasis>helloworld</emphasis> directory inside of this
      deployment structure is your PHOCOA applications directory.</para>

      <para><note>
          <para>This "inner" directory is the root directory of your PHOCOA
          application, and is what you should check in to your version control
          system. The log/ and runtime/ directories are typically not
          versioned resources.</para>
        </note></para>

      <bridgehead>Application Directory Structure</bridgehead>

      <para>Now let's have a look at the directory structure.</para>

      <screen>$ ls -l helloworld/helloworld
total 20
drwxrwxr-x  3 apinstein ttimobile 4096 May 31 07:35 classes
drwxrwxr-x  2 apinstein ttimobile 4096 May 31 11:12 conf
drwxrwsr-x  9 apache    ttimobile 4096 May 30 15:53 modules
drwxrwxr-x  5 apinstein ttimobile 4096 May 30 18:14 skins
drwxrwxr-x  3 apinstein ttimobile 4096 May 31 09:00 wwwroot</screen>

      <para>The <emphasis>classes</emphasis> directory is where all of your
      classes go. These are classes specific to your application.</para>

      <para>The <emphasis>conf</emphasis> directory contains all configuraiton
      files.</para>

      <para>The <emphasis>modules</emphasis> directory is where all components
      go. These components are the building blocks of your application and
      include both entire pages and sub-components.</para>

      <para>The <emphasis>skins</emphasis> directory is where all skins
      go.</para>

      <para>The <emphasis>wwwroot</emphasis> directory is a public wwwroot
      that contains the front controller for the PHOCOA project. All public
      documents (i.e. the tradiditional public www root) go in
      wwwroot/www/.</para>

      <bridgehead>Initial Configuration</bridgehead>

      <para>First thing to do is configure the framework.</para>

      <screen>$ ls -l helloworld/helloworld/conf                                                                                                                                 alanpinstein@g5:~/dev/sandbox
total 24
-rw-r--r--   1 alanpins  staff  1272 May 18 14:24 httpd.conf
-rw-r--r--   1 alanpins  staff  1561 May 18 12:58 webapp.conf</screen>

      <para>The httpd.conf file is the Apache configuration for your
      application. You should customize it to match your domain and path to
      where you put PHOCOA. Most of this was done automatically by the Phing
      <emphasis>newproject</emphasis> build. Examine the file to be sure it
      matches what you want. You can of course make any corrections to
      mistakes you may have made earlier regarding hostname, port, etc. Also,
      examine the WebDAV setup (optional - feel free to comment this out if
      you don't have or want WebDAV access). We assume that you are familiar
      with apache setup.</para>

      <note>
        <para>WebDAV can be useful when working on an application remotely.
        Since PHOCOA includes a Mac OS X application to graphically manage
        some configuration files, using WebDAV enables you to use the PHOCOA
        Builder Application on your computer, but working on a PHOCOA
        application directory on a remote computer. For this reason, you need
        only share the "modules" directory of your webapp.</para>
      </note>

      <para>Then, include your application's httpd configuration file in your
      main httpd.conf like so:</para>

      <programlisting>Include /path/to/helloworld/helloworld/conf/httpd.conf</programlisting>

      <para>Now restart Apache.</para>

      <para>Next up is the PHOCOA conf file. Open up webapp.conf. Read through
      it, setting up each directive as explained by the comments. It should
      also be set up correctly because of the Phing task. You may need to
      tweak the PHP include_path setting to ensure that PHOCOA can see your
      smarty install.</para>

      <para>At this point, you should be able to access the site via the web.
      You should be able to access the application via
      http://servername/.</para>

      <para>Now, we can move on to the tutorial!</para>
    </section>

    <section>
      <title>Module / Page Component Architecture</title>

      <bridgehead>Modules</bridgehead>

      <para>The basic unit of work in a PHOCOA application is the module. A
      module is a collection of views and code related to a single function.
      It is conceptually the same as a single PHP file in a traditional PHP
      application. There may be multiple actions, web pages, etc, but it's all
      stored in one file.</para>

      <para>Each PHOCOA module is a single PHP file that contains a single
      WFModule subclass. This subclass will have specially named functions
      that you create to set up pages and respond to user actions.</para>

      <para>Because each module has multiple pages, actions, etc., each module
      in PHOCOA is essentially a reusable web component. The components can be
      used one-at-a-time to build complete pages, or you can composite modules
      together to create complex layouts and behaviors.</para>

      <para>Modules are invoked via an <property>invocationPath</property>
      which looks like
      <property>path/to/module/pageName/param1/param2</property>. Obviously
      this looks a lot like a URL. When you go to a URL of a PHOCOA
      application, the request controller parses out the
      <property>invocationPath</property> from the URL and executes the
      module. Modules that include other modules simply supply the
      <property>invocationPath</property> directly.</para>

      <bridgehead>Pages</bridgehead>

      <para>Each module can contain an arbitrary number of pages. A page is
      simply a single web view that a user can see. You can think of it as a
      web page, a view, a screen, whatever works for you. For instance, you
      may have one view that is an input form, and another view that is used
      for telling the user the form's action succeeded.</para>

      <bridgehead>Actions</bridgehead>

      <para>Each page has a number of actions. Actions are trigger by the user
      submitting a form. When the user submits a form, PHOCOA will hand off
      control to an action handler in your module where you can respond to the
      action.</para>

      <para>It should be noted that not all requests have actions. It is
      possible to just load a page in a module WITHOUT an action. In this
      case, the module can display the default page, or could look in the
      parameters passed to it to find information used to load default data
      into the page.</para>
    </section>

    <section>
      <title>Building "Hello, World!"</title>

      <para>Let's put PHOCOA to work with a simple example. We start out by
      creating a new module, "helloworld".</para>

      <note>
        <para>Your new project alread has a completed helloworld module, so
        we'll just explain how it was built.</para>
      </note>

      <para>To create a new module, we have a Phing task to help us:</para>

      <screen>$ php5 /Users/alanpinstein/dev/sandbox/phocoa/phocoa/framework/createModule.php helloworld helloworld</screen>

      <note>
        <para>This script isn't yet wrapped by Phing yet so we just run the
        script directly.</para>
      </note>

      <para>The createModule task automatically creates a new module with a
      single page.</para>

      <para><programlisting>class helloworld extends WFModule
{
    /**
      * Tell system which page to show if none specified in the URL. 
      */ 
     function defaultPage()
     {
         return 'helloWorld';
     }
}</programlisting></para>

      <para>WFModule is an abstract class, requiring only one method,
      "defautPage()". This method simply tells the system what page to load if
      none is specified.</para>

      <para>Next, let's examine the helloWorld page.</para>

      <para>Each page in PHOCOA has three parts. The .tpl file (the HTML
      Smarty template), the .instances file (contains a list of all WFView
      instances used in the template), and the .config file (contains the
      configuration of the WFView instances declared in the .instances file).
      PHOCOA needs a list of all UI instances used in the view so that it can
      work its magic in maintaining state, etc. The .config file is used to
      configure each widget, for instance by specifying labels, sizes,
      formatters, and other attributes. The .config file is also used to set
      up Bindings, which is how PHOCOA links UI widget data to your model.
      Don't worry about these details for now, though; we'll explain further
      as we go along.</para>

      <important>
        <para>In the following examples, the contents of .instances and
        .config files will be shown. These files are PHP files and need to
        have the PHP tags: <code>&lt;?php ... ?&gt;</code> surrounding any PHP
        code you see, but for brevity they have been left out.</para>
      </important>

      <para>PHOCOA includes a Phing task to add a page to an existing module
      as well. This script should be run from inside the module directory that
      you want to add the page to.</para>

      <screen>$ php5 /Users/alanpinstein/dev/sandbox/phocoa/phocoa/framework/createPage.php helloworld</screen>

      <note>
        <para>This script isn't yet wrapped by Phing yet so we just run the
        script directly.</para>
      </note>

      <note>
        <para>The createModule script uses the createPage script to create the
        default page. The helloworld module already has a helloworld page, so
        you don't need to run it again.</para>
      </note>

      <para>Now, edit the helloWorld.tpl file with a classic message:</para>

      <para><programlisting>Hello, World! </programlisting></para>

      <para>That's all that's needed to make a simple web page in PHOCOA.
      Simply load up the URL for this page: http://localhost/webapp/helloworld
      and you should see the helloworld page!</para>
    </section>

    <section>
      <title>Forms</title>

      <para>One of PHOCOA's biggest benefits is that it automatically
      maintains state of all GUI widgets across requests. Without any code at
      all, you can have an arbitraily complex form which automatically
      remembers all values perfectly from one request to another. PHOCOA also
      has integrated data validation and error handling that keep track of
      errors on a field-by-field basis. Thus, PHOCOA greatly simplifies the
      creation of user-friendly forms that automatically remember their state
      and show errors on a per-field basis.</para>

      <para>Our example also includes a form, which you should have seen when
      you loaded the URL. Let's examine the helloWorld.tpl file to see how the
      form is set up:</para>

      <programlisting>
        {WFForm id="form"} 
        Email: {WFTextField id="email"} 
        {WFSubmit id="submit"} 
        {/WFForm} 
      </programlisting>

      <para>Now we need to declare these three widgets in the .instances
      file.</para>

      <para><tip>
          <para>If you're using Mac OS X Tiger, you can use the PHOCOA Builder
          application to manage the .instances and .config files
          graphically.<screenshot>
              <screeninfo>PHOCOA Builder</screeninfo>

              <mediaobject>
                <imageobject>
                  <imagedata fileref="PHOCOA%20Builder.png" />
                </imageobject>
              </mediaobject>
            </screenshot></para>
        </tip>The end result should be that the helloWorld.instances file
      looks like:</para>

      <programlisting>
        $__instances = array( 
            'form' =&gt; array('class' =&gt; 'WFForm', 'children' =&gt; array( 
                'submit' =&gt; array('class' =&gt; 'WFSubmit'), 
                'email' =&gt; array('class' =&gt; 'WFTextField'),
                )
            )
        ); 
      </programlisting>

      <para>The format of the .instances file is a PHP associative array, with
      the first level of keys being the instance ID. The instance ID is the
      unique ID for this page for the given instance. Then, for each instance,
      you must declare the class, and optionally children. As you can see
      above, WFForm is a container widget that contains other widgets. You can
      tell this because the {WFForm} tag in the .tpl file has a closing
      tag.</para>

      <para>When PHOCOA processes the .instances file, it will create an
      instance of the given class for the given ID. The rest of the system
      then can interact with the widgets by ID. In code, you can access a
      widget with:</para>

      <programlisting> $myTextField = $page-&gt;outlet('MyTextFieldInstanceID');</programlisting>

      <para>So, what action gets run when the user submits this form? The
      action methods are simply specially named methods of the WFModule
      subclass. Here's the prototype:</para>

      <para><function>&lt;pageName&gt;_&lt;actionID&gt;_Action($requestPage)</function></para>

      <para>So, we now need to define a function in our WFModule subclass to
      run when the submit button is clicked. Add this to the helloworld.php
      file:</para>

      <programlisting> function helloWorld_submit_Action($page) {} </programlisting>

      <para>For now, our action method won't do anything. However, we have to
      declare it or the framework will throw an exception.</para>

      <para>So, now load the page again and you should see a form. Enter in
      some data and press the submit button. You will notice that the form
      will be re-displayed with the data you entered still there. This is a
      simplified example of PHOCOA's state-maintenance capabilities. Any form
      elements that are added will automatically have their state maintained.
      All HTML form elements are available.</para>
    </section>

    <section>
      <title>Data</title>

      <para>While it's somewhat interesting to see the form maintain its
      state, it's not particularly useful on its own. Typically a form
      submission will need to do something, and typically that will involve
      moving the data from the form to an object, validating the data, and
      eventually performing an action. Sometimes, you'll also need to format
      the data in a more human-readable way than it is stored, for instance,
      timestamps.</para>

      <para>The glue layer between the GUI and the model is another huge
      benefit of PHOCOA. Based on Apple's Controller Layer, PHOCOA automates
      the process of moving data between the GUI elements and the data layer.
      Instead of writing code to move the data between the layers, the PHOCOA
      controller layer does this automatically. All you have to do is
      configure the GUI elements to "bind" them to your model objects. This is
      done without any coding, and once it's done, the controller layer
      automatically keeps your GUI in sync with your data as well as
      automatically providing data validation and error handling.</para>

      <para>To extend our example and really explore PHOCOA, we're going to
      build a classic web application, a form-to-email page.</para>

      <para>First, let's define our new class, ExampleEmail. Normally each
      class is stored in its own file, but for simplicity, we'll just put our
      ExampleEmail class in helloworld.php. Add the following:</para>

      <programlisting>
        class ExampleEmail extends WFObject 
        { 
             protected $toEmail; 
             protected $subject; 
             protected $message;
            
             function send()
             {
                 $sent = mail( $this-&gt;toEmail, $this-&gt;subject, $this-&gt;message );
                 return $sent;
             }
        } 
      </programlisting>

      <para>Now, of course, we also need a bigger form, so edit
      helloWorld.tpl:</para>

      <programlisting>
        {WFForm id="form"} 
             Email: {WFTextField id="email"}&lt;br /&gt;
             Subject: {WFTextField id="subject"}&lt;br /&gt;
             Message: {WFTextArea id="message"}&lt;br /&gt;
             {WFSubmit id="submit"} 
        {/WFForm} 
      </programlisting>

      <para>Since we've added components to the page, we need to declare them
      in the helloWorld.instances file, which should now look like:</para>

      <programlisting>$__instances = array(
                'form' =&gt; array('class' =&gt; 'WFForm', 'children' =&gt; array(
                      'subject' =&gt; array('class' =&gt; 'WFTextField'),
                      'message' =&gt; array('class' =&gt; 'WFTextArea'),
                      'submit' =&gt; array('class' =&gt; 'WFSubmit'),
                      'email' =&gt; array('class' =&gt; 'WFTextField'),
                      )
                 ),
              );</programlisting>

      <para>Now, of course we need to link the form elements to our new
      ExampleEmail class. This is where PHOCOA starts to get really
      interesting. You won't have to write ANY code to make this
      happen!</para>

      <para>First off, we will need an instance of the ExampleEmail class,
      right? Well, just like there is the helloWorld.instances file, there is
      also a mechanism for instantiating objects for the module. These are
      called Shared Instances, and they are conceptually similar to
      instantiating objects in a nib file in Cocoa. You can create a
      shared.instances file, and configure those instances with a
      shared.config file. All instances declared in shared.instances will be
      created automatically when your module is initialized.</para>

      <para>So, let's set up an ExampleEmail instance! Create a file called
      shared.instances, and enter the following:</para>

      <programlisting>$__instances = array( 'email' =&gt; 'ExampleEmail',); </programlisting>

      <para>Of course, once again if you're on Mac OS X Tiger, you can use
      PHOCOA Builder to create a shared instance.</para>

      <para>Now we are guaranteed to have an instance of ExampleEmail set up
      as an instance variable of our helloworld class.</para>

      <para>Next up, we need to link the form elements to the members of our
      ExampleEmail class. For this, we need to introduce a concept called
      Bindings. Bindings are a way to link the property of one class to the
      property of another class.</para>

      <para><tip>
          <para>If you're familiar with COCOA, these work very similarly to
          bindings in Cocoa, with the small difference that in PHOCOA the
          bindings are not implemented with a real-time observer pattern.
          Since PHP is stateless, we decided to simply push values from
          bindings once at the beginning of the request cycle, and pull values
          from bindings once at the end of the request cycle, just before
          rendering.</para>
        </tip></para>

      <para>So, to set up the bindings we're going to edit the
      helloWorld.config file, to the following:</para>

      <para><programlisting>$__config = array(
              'subject' =&gt; array(
                  'bindings' =&gt; array(
                      'value' =&gt; array(
                          'instanceID' =&gt; 'email',
                          'controllerKey' =&gt; '',
                          'modelKeyPath' =&gt; 'subject',
                          ),
                      ),
                  ),
              'message' =&gt; array(
                  'bindings' =&gt; array(
                      'value' =&gt; array(
                          'instanceID' =&gt; 'email',
                          'controllerKey' =&gt; '',
                          'modelKeyPath' =&gt; 'message',
                          ),
                      ),
                  ),
              'email' =&gt; array(
                  'bindings' =&gt; array(
                      'value' =&gt; array(
                          'instanceID' =&gt; 'email',
                          'controllerKey' =&gt; '',
                          'modelKeyPath' =&gt; 'toEmail',
                          ),
                      ),
                  ),
              ); </programlisting></para>

      <para>Once again, if you're using PHOCOA Builder, you can do this
      graphically.</para>

      <para>To explain what's happening here, let's look at subject first. We
      create a 'bindings' key for 'subject', and declare that we want to bind
      the "value" property of the "subject" instance (which is a WFTextField).
      We want to bind the "value" property to the "email" instance variable of
      our helloworld class, and we want to link it to the "subject" property
      of the "email" instance. For now, don't worry about the
      controllerKey.</para>

      <para>What is a modelKeyPath? Let's introduce another concept that we
      call Key-Value Coding. This again will be familiar to Cocoa developers.
      Basically, the idea is that classes have a number of properties (their
      members / instance variables). Key-Value Coding provides a generic
      mechanism for accessing or mutating these members. The following generic
      functions:</para>

      <para><programlisting>function valueForKey($key);
function setValueForKey($value, $key);</programlisting></para>

      <para>provide access to get/set any properties of classes derived from
      WFObject. If you'll remember, our ExampleEmail class extends WFObject,
      and this is why.</para>

      <para>So, we can call:</para>

      <para><programlisting>$email-&gt;setValueForKey('Test Message', 'subject')</programlisting></para>

      <para>and this will update the subject of our exampleEmail class. The
      binding that we've just configured will now do this for you
      automatically. It will also take its value from the email instance, if
      there is one. The same is also true for the <property>message</property>
      and <property>email</property> fields.</para>

      <para>The <function>valueForKey</function> /
      <function>setValueForKey</function> functions try a variety of
      approaches to access the property's data. First, they will use accessors
      with a particular naming convention: <function>&lt;key&gt;()</function>
      and <function>set&lt;Key&gt;()</function> where &lt;key&gt; is the
      property name. For instance, <function>emailTo()</function> would be
      used as the accessor for the <property>emailTo</property> member, and
      <function>setEmailTo($value)</function> for the mutator. If these
      specially named accessors are not available, the system will try to
      access the member directly.</para>

      <para>One last thing before we try it out. Of course, we need to have
      our action handler call the send() method on our email instance when the
      form is submitted, right? So, modify the action handler to the
      following:</para>

      <programlisting>function helloWorld_submit_Action($page)
{
    $this-&gt;email-&gt;send();
}</programlisting>

      <para>As mentioned previously, because of the setup we did in
      shared.instances, we're guaranteed to have an instance variable in our
      helloworld class populated with an ExampleEmail instance. So we need
      only to tell it to send!</para>

      <para>Your mailer should work now. Try it out by sending an email to
      yourself. Assuming your mailer setup for PHP is correct, you should get
      an email!</para>
    </section>

    <section>
      <title>Responding With a Different Page</title>

      <para>At the end of the last section, we had a working mailer. However,
      the UI didn't change when the user submitted the form. Probably we'll
      want to display a "success" message when the mail is sent. Let's walk
      through the steps to display a different page as a response to an
      action.</para>

      <para>First, let's create the success page. Use the handy createPage
      script again to create a page named "emailSuccess", then edit the
      template to look like this:</para>

      <programlisting>&lt;p&gt;Successfully sent email!&lt;/p&gt;
To: {WFLabel id="email"}&lt;br /&gt; 
Subject: {WFLabel id="subject"}&lt;br /&gt; 
Message: {WFLabel id="message"}</programlisting>

      <para>Now, set up the emailSuccess.instances:</para>

      <para><programlisting>$__instances = array(
              'message' =&gt; array('class' =&gt; 'WFLabel'),
              'subject' =&gt; array('class' =&gt; 'WFLabel'),
              'email' =&gt; array('class' =&gt; 'WFLabel'),
          ); </programlisting></para>

      <para>and emailSuccess.config:</para>

      <programlisting>
$__config = array(
        'message' =&gt; array(
                'bindings' =&gt; array(
                        'value' =&gt; array(
                                'instanceID' =&gt; 'email',
                                'controllerKey' =&gt; '',
                                'modelKeyPath' =&gt; 'message',
                        ),
                ),
        ),
        'subject' =&gt; array(
                'bindings' =&gt; array(
                        'value' =&gt; array(
                                'instanceID' =&gt; 'email',
                                'controllerKey' =&gt; '',
                                'modelKeyPath' =&gt; 'subject',
                        ),
                ),
        ),
        'email' =&gt; array(
                'bindings' =&gt; array(
                        'value' =&gt; array(
                                'instanceID' =&gt; 'email',
                                'controllerKey' =&gt; '',
                                'modelKeyPath' =&gt; 'toEmail',
                        ),
                ),
        ),
);
      </programlisting>

      <para>Now, in the our action handler, we want to show the success page
      if the email was sent, so we add a line to set up the reponse page to
      use:</para>

      <programlisting>function helloWorld_submit_Action($page)
{
    $this-&gt;email-&gt;send();
    $this-&gt;setupResponsePage('emailSuccess');
}</programlisting>

      <para>Try submitting the email form again. This time, you should see the
      success page you've just created.</para>
    </section>

    <section>
      <title>Validating data</title>

      <para>Let's add some validation to our email class. For instance, let's
      say that we want to require a properly-formatted email address, and the
      subject cannot be blank. Of course, we'll also want to show the errors
      to the user. How to accomplish this with PHOCOA?</para>

      <para>It's time once again to introduce another concept: Key-Value
      Validation. Similar to Key-Value coding, the Key-Value Validation
      mechanism looks for specially-named functions of your class, with the
      following prototype:</para>

      <para><programlisting>boolean validate&lt;Key&gt;(&amp;$value, &amp;$edited, &amp;$errors)</programlisting></para>

      <para>It is very important to notice the pass-by-reference used on all
      three parameters.</para>

      <para>So, we can implement our two validators by adding the following
      code to ExampleEmail:</para>

      <programlisting>
    function validateToEmail(&amp;$value, &amp;$edited, &amp;$errors)
    {
        $value = trim($value);
        $edited = true;
        if (preg_match("/[A-z0-9._-]+@[A-z0-9-]+\.[A-z0-9-\.]*[A-z]+$/", $value) == 1) return true;

        $errors[] = new WFError("The email you entered is not a properly formatted email address.");
        return false;
    }

    function validateSubject(&amp;$value, &amp;$edited, &amp;$errors)
    {   
        $value = trim($value);
        $edited = true;
        if ($value != '') return true;

        $errors[] = new WFError("The subject cannot be blank.");
        return false;
    }</programlisting>

      <para>Validators in PHOCOA are a bit different than some validation
      mechanisms. Validators are called BEFORE the actual value is set, by the
      Bindings system, as a pre-flight mechanism. Doing it this way prevents
      invalid data from ever being in the class.</para>

      <para>The validators can also do normalization of the data. Since the
      value is passed by reference, you can normalize the data in any
      appropriate way. If you do alter the data, be sure to set edited to
      true.</para>

      <para>Notice also that the errors parameter is an array. This allows you
      to specify multiple errors during validation.</para>

      <para>Now that we can detect errors, we'll want to display the errors to
      the user as well, so let's edit the helloWorld.tpl file:</para>

      <programlisting>
{WFShowErrors}

{WFForm id="form"}
    Email: {WFTextField id="email"}&lt;br /&gt; {WFShowErrors id="email"}
    Subject: {WFTextField id="subject"}&lt;br /&gt; {WFShowErrors id="subject"}
    Message: {WFTextArea id="message"}&lt;br /&gt;
    {WFSubmit id="submit"}
{/WFForm}
      </programlisting>

      <para>You'll notice the addition of several {WFShowErrors} tags. This is
      a special function that looks up the errors generated by the specified
      widget ID and dislpays them. If no id is specified, all errors will be
      displayed.</para>

      <para>Now try the form again, but this time enter invalid data for both
      the Email and Subject fields and then submit. You'll see that all of the
      errors are listed above the form, and the specific errors are again
      repeated next to the relevant form elements.</para>

      <para>PHOCOA performs all validation as it is moving the data to your
      objects via bindings. If the validation fails at all, then the "action"
      method will not be called. Sometimes of course, there will be no during
      the bindings phase, but errors may still occur when processing the
      action. For instance, saving data to a database might return an error.
      In this case, you can easily add additional errors using the addError()
      function of WFPage.</para>
    </section>

    <section>
      <title>Formatting Data</title>

      <para>There's one more major component to the PHOCOA framework that you
      should know about, and that's Formatters. Many data types are not
      human-readable by default, or are not in the desired format. Good
      examples are timestamps and number formats.</para>

      <para>We'll now extend our example to show off formatters.</para>

      <para>Let's add a timestamp to our ExampleEmail class:</para>

      <para><programlisting> protected $sendTimestamp; </programlisting></para>

      <para>and in the send() method:</para>

      <para><programlisting> $this-&gt;sendTimestamp = time(); </programlisting></para>

      <para>Now, let's add the date sent to the success page:</para>

      <para><programlisting>Date Sent: {WFLabel id="timestamp"}&lt;br /&gt;
      </programlisting></para>

      <para>And now of course we need to add it to the emailSuccess.instances
      file:</para>

      <para><programlisting> 'timestamp' =&gt; array('class' =&gt; 'WFLabel', 'children'
      =&gt; array()), </programlisting></para>

      <para>and set up the binding in emailSuccess.config:</para>

      <programlisting>
        'timestamp' =&gt; array(
                'bindings' =&gt; array(
                        'value' =&gt; array(
                                'instanceID' =&gt; 'email',
                                'controllerKey' =&gt; '',
                                'modelKeyPath' =&gt; 'sendTimestamp',
                        ),
                ),
        ),
      </programlisting>

      <para>If you try sending another email now, you'll see that the Date
      Sent is an ugly integer, or UNIX time. To format it, we can use a PHOCOA
      formatter. Formatters are WFFormatter subclasses, and include
      WFNumberFormatter, WFSQLDateFormatter, and WFUNIXDateFormatter. We want
      to use a WFUNIXDateFormatter.</para>

      <para>To add a formatter, you could instantiate one manually in the
      helloworld.php file, and then link it to the timestamp label. However,
      why bother coding if you don't have to? Let's instantiate a
      WFUNIXDateFormatter by adding some code in shared.instances:</para>

      <para><programlisting> 'dateSentFormatter' =&gt; 'WFUNIXDateFormatter',
      </programlisting></para>

      <para>Now, we want to make the timestamp label use the formatter.
      There's another feature of the .config files besides bindings; you can
      use them to set up properties of the instances. Supply a property name
      and value, and PHOCOA will configure that property with a
      <function>setValueForKey()</function> call.</para>

      <para>So, in emailSuccess.config, we can set the "formatter" property to
      the formatter we instantiated in shared.instances by editing the
      'timestamp' entry:</para>

      <programlisting>
        'timestamp' =&gt; array(
                'properties' =&gt; array(
                        'formatter' =&gt; '#module#dateSentFormatter',
                ),
                'bindings' =&gt; array(
                        'value' =&gt; array(
                                'instanceID' =&gt; 'email',
                                'controllerKey' =&gt; '',
                                'modelKeyPath' =&gt; 'sendTimestamp',
                        ),
                ),
        ),
      </programlisting>

      <para>Notice the #module# preceding the shared instance ID; since you
      can use the config mechanism to set up values such as strings, integers,
      booleans, and doubles, we needed a special flag to indicate that you
      want to link it to the value of an instance variable of the module,
      which is what shared instances are.</para>

      <para>Now, submit the form again and you'll see the new, nicely
      formatted date. You can also set up your own format string, by using
      shared.config to set up the formatString property of the
      WFUNIXDateFormatter instance. WFUNIXDateFormatter simply wraps PHP's
      <function>date()</function> function, using "r" by default as the format
      string. Try your own format string by editing shared.config:</para>

      <programlisting>
'dateSentFormatter' =&gt; array(
    'properties' =&gt; array(
        'formatString' =&gt; 'F j, Y, g:i a'
    ),
),</programlisting>

      <para>Send another email and you'll see the new format.</para>

      <para>Another note, formatters are reversible. So, if you have a date
      field that you want to be editable, feel free to add a formatter to a
      WFTextField instance. The formatter will attempt to convert the edited
      string value using PHP's <function>strtotime()</function> function. In
      this case, you might want to add a validator to your date property to
      make sure it's not NULL, which is what you'll get if the string was not
      parseable by <function>strtotime().</function></para>
    </section>

    <section>
      <title>Setting Page-Level Attributes</title>

      <para>It is a best-practice to set up the Title, Meta Keywords, and Meta
      Description of each page to keep the information relevant and help with
      search engine optimization. PHOCOA provides a callback mechanism on a
      page-by-page basis to all you to edit this information.</para>

      <para>The prototype of the callback is:</para>

      <programlisting>function &lt;pageName&gt;_SkinSetup($skin)</programlisting>

      <para>The function should be implemented in your WFModule subclass. Here
      is an example:</para>

      <programlisting>    function helloWorld_SetupSkin($skin)
    {   
        $skin-&gt;setTitle("Hello, World, from PHOCOA!");
        $skin-&gt;addMetaKeywords(array('keyword 1', 'keyword 2'));
        $skin-&gt;setMetaDescription('Hello world example module in PHOCOA.');
    }</programlisting>
    </section>

    <section>
      <title>PHOCOA API Documentation</title>

      <para>The complete PHOCOA documentation is available online at <ulink
      url="???">http://phocoa.com/docs/phpdocs/</ulink>.</para>
    </section>

    <section>
      <title>Further Explorations</title>

      <bridgehead>PHOCOA Key-Value Coding and Bindings Primer</bridgehead>

      <para>PHOCOA bindings make it easy to show information from your
      Key-Value Coding Compliant objects, which includes Propel objects if
      you've implemented the Propel changes noted in the appendix.</para>

      <para>You can use WFObject's valueForKeyPath() function to access
      properties of your objects. For instance, if you have a Book object, and
      want to access the birthdate of the author, you could use:</para>

      <screen>$authorBirthDate = $book-&gt;valueForKeyPath("author.birthDate");</screen>

      <para>Which is equivalent to:</para>

      <screen>$authorBirthDate = $book-&gt;getAuthor()-&gt;getBirthDate();</screen>

      <para>While it doesn't seem that advantageous from just looking at the
      code, it becomes much more powerful when coupled with PHOCOA
      bindings.</para>

      <para>Let's say you want to have a web page that shows the details of a
      book. Normally, you'd have to assign the $book object to your template
      engine and then put something like
      {$book-&gt;getAuthor()-&gt;getBirthDate()} in your template code.</para>

      <para>With PHOCOA, instead of assigning the $book object to your
      template, you instead make the $book object one of the instance
      variables of your module. Then, you set up a WFLabel object and bind the
      "value" of the WFLabel to the $book variable, and set a keyPath of
      "author.birthDate" as the modelKeyPath.</para>

      <para>Now, even this doesn't seem that different. However, as you might
      be starting to notice, the keyPath for the WFLabel object isn't
      <emphasis>programming</emphasis>, it's
      <emphasis>configuration</emphasis>. So, if you want to change the value
      of the label, you just edit the configuration of the keyPath and the new
      value will be used.</para>

      <para>Furthermore, because you're using PHOCOA GUI widgets, you get
      access to a host of additional functionality without having to add any
      code. Want to truncate the string after 30 characters? Just configure
      the "ellipsisAfterChars" property of the label. Want to hide the label
      in certain circumstances? Just bind the "hidden" property of the WFLabel
      to a function returning a boolean value and PHOCOA does the rest. Want
      the birthdate to show up as a properly formatted date? Just provide a
      formatter to the WFLabel. Want to use a formatString to combine multiple
      values? Use the ValuePattern binding! This is all done via the
      configuration file, not via coding.</para>

      <bridgehead>PHOCOA's Skin System</bridgehead>

      <para>PHOCOA's skin system provides a simple yet flexible way to control
      the template being used to render each page. The skin system has three
      layers:</para>

      <para><itemizedlist>
          <listitem>
            <para><emphasis>Skin Type (Skin Delegate) </emphasis>At the top
            level is the Skin Type. Each skin type can have its own distinct
            infrastructure of common components, which are managed by its Skin
            Delegate. The skin type is not a layout in and of itself; rather
            it is just an implementation of the layout from a semantic
            perspective. The Skin Delegate provides an interface for the skins
            (explained below) to access the data common to the layout. An
            example of a skin type would be an "Admin" interface and a
            "Public" interface for an application.</para>
          </listitem>

          <listitem>
            <para><emphasis>Skin</emphasis> Each skin is a concrete
            implementation of an actual layout. There can be any number of
            skins that implement layouts for each Skin Type.</para>
          </listitem>

          <listitem>
            <para><emphasis>Skin Theme</emphasis> Each skin is further
            subdivided, optionally, into themes. Themes provide an easy way to
            use the same basic layout (the Skin) while changing colorschemes,
            graphics packages, etc.</para>
          </listitem>
        </itemizedlist>By default, a new PHOCOA application has a single Skin
      Type (simple) and two Skins (simple1, simple2). Simple1 has only one
      theme, while simple2 has two themes set up.</para>

      <para>The bundled "SkinInfo" module provides an interactive browser for
      the installed skins on any PHOCOA application to make it easy to
      understand and browse the skin infrastructure.</para>
    </section>

    <section>
      <title>Further Resources</title>

      <para>Visit <ulink url="???">http://phocoa.com</ulink> for the latest
      news, downloads, etc. There are also a mailing lists that you can join
      at <ulink url="???">http://lists.phocoa.com</ulink>.</para>
    </section>

    <section>
      <title>Conclusion</title>

      <para>Hopefully this brief tutorial has showed to you the benefits of
      PHOCOA development, and taught you enough to experiment on your own.
      Thanks for reading!</para>
    </section>

    <section>
      <title>Appendix: Using PHOCOA With Propel</title>

      <para>PHOCOA is designed to use Propel as an analog for Core Data. By
      making a 2-line change to the Propel code, your Propel objects will
      automatically be Key-Value Coding compliant, making it very simple to
      make your PHOCOA application interact with Propel.</para>

      <para>To update your Propel to work with Phocoa, simply edit the
      propel/om/BaseObject.php file in 2 places:</para>

      <para><orderedlist>
          <listitem>
            <para>Include the PHOCOA WFObject.php base object file:</para>

            <screen>require_once FRAMEWORK_DIR . '/framework/WFObject.php';</screen>
          </listitem>

          <listitem>
            <para>Make the Propel BaseObject a subclass of the PHOCOA WFObject
            base class:</para>

            <screen>abstract class BaseObject<emphasis> extends WFObject </emphasis>{</screen>
          </listitem>
        </orderedlist></para>

      <para>That's it! Your Propel install is now fully compatible with PHOCOA
      to act as the data store for your objects.</para>
    </section>
  </chapter>
</book>