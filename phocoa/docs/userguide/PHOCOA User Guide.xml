<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<book>
  <title>PHOCOA User Guide</title>

  <chapter>
    <title>Introduction to PHOCOA</title>

    <section>
      <title>Overview</title>

      <para>PHOCOA is an object-oriented, event-driven, componentized, MVC
      (model-view-controller) web application framework based on Apple's Cocoa
      architecture.</para>

      <para>PHOCOA's primary intent is to make developing web applications in
      PHP easier, faster, and with fewer bugs. The framework handles most of
      the "dirty work" of programming by removing the need to write much glue
      code for data binding (moving data between the model layer and view
      layer of your application), validation, error handling, request
      processing, etc. Most of your time will be spent designing your GUI and
      writing application-specific logic rather than dealing with form data,
      database calls, etc.</para>

      <para>As much as possible, PHOCOA aims to make it so that as much of the
      code you write as possible is specific to your own application.</para>
    </section>

    <section>
      <title>External Technologies</title>

      <para>PHOCOA relies on several major technologies to work its
      magic:</para>

      <itemizedlist>
        <listitem>
          <para>PHP 5 - programming language</para>
        </listitem>

        <listitem>
          <para>Smarty - user interface / presentation layer</para>
        </listitem>

        <listitem>
          <para>Propel - database abstraction / model layer</para>
        </listitem>
      </itemizedlist>

      <para>A complete list of dependencies is available.</para>
    </section>

    <section>
      <title>PHOCOA Technologies</title>

      <para>PHOCOA itself contributes several technologies to the
      framework.</para>

      <itemizedlist>
        <listitem>
          <para>Request Controller - handles automatically handing off web
          requests to various custom "modules" that will implement the
          application's logic.</para>
        </listitem>

        <listitem>
          <para>Page Controller - handles initializing, displaying, and
          maintaining state of UI objects.</para>
        </listitem>

        <listitem>
          <para>Bindings - provides the ability to "bind" UI objects to data
          objects and thereby elimintate the need to write glue code to move
          data between the model and the view layers.</para>
        </listitem>

        <listitem>
          <para>PHOCOA Builder - a GUI app (for Mac OS X) that lets you easily
          configure the UI and bindings for your application.</para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter>
    <title>Motivation</title>

    <section>
      <title>Classic Problems of Web Development, and How PHOCOA Solves
      Them</title>

      <para>Developing web applications presents a variety of challenges.
      Listed below are a number of classic web development architectural
      problems, and how PHOCOA provides solutions.</para>

      <itemizedlist>
        <listitem>
          <para>Separation of Data, Presentation, and Glue layers of the
          code.</para>

          <para>Presentation templates should be clearly separated from other
          code, allowing designers to easily edit the look and feel without
          breaking the appilcation or dealing with business logic.</para>

          <para>Data model code should represent only the pure data model of
          your system, and have no code related to UI.</para>

          <para>Glue code links the model layer to the view layer. Glue code
          is typically the code for each "web page". It loads up the right
          data and view pieces for that page, and links the two
          together.</para>

          <para><emphasis>This problem is typically solved with a MVC
          design.</emphasis></para>

          <para>PHOCOA uses a MVC architecture as part of its
          framework.</para>

          <para>PHOCOA has some flexibility in the model layer, but we
          recommend Propel for model objects that are stored in an RDBMS. Of
          course, not all of your model objects will be persisted, and you can
          write your own classes as well. You can use other persistence
          solutions as well, but this may break some of the functionality of
          the framework.</para>

          <para>For the presentation layer, PHOCOA uses a template system to
          separate the presentation layer from the Model and Controller
          layers. PHOCOA uses the Smarty template engine, but it is possible
          that the system could be extended to use other template
          engines.</para>

          <para>PHOCOA's controller layer is one of the most powerful parts of
          the framework. The PHOCOA controller layer provides automatic
          state-maintenance of form data, a formalized data validation
          mechanism, and a bindings layer. All of these items will be
          discussed in more detail below, but have the net effect of
          drastically reducing the amount of code you have to write.</para>
        </listitem>

        <listitem>
          <para>Persistence / Retrieval of Model objects to a database.</para>

          <para>Model objects should be accessible through a single interface
          and easily retrieved and persisted. Typically this means saving
          complex relational model data in a RDBMS, as well as querying the DB
          and restoring model state.</para>

          <para><emphasis>This problem is typically solved by
          Object-Relational mapping tools.</emphasis></para>

          <para>PHOCOA currently uses a modified version of Propel to provide
          object persistence. The modification that is made is simply to make
          the Propel BaseObject subclass the PHOCOA framework's base object,
          WFObject. This allows Propel objects to provide the requisite
          interfaces for integrating with PHOCOA.</para>
        </listitem>

        <listitem>
          <para>"Skinning" - having an overall look and feel for a site that
          is easily switched out. Also, having different look &amp; feel for
          different parts of a site. Also, getting data into the HEAD section
          of the page.</para>

          <para>All web sites have graphics that are used for every page. We
          call this a "skin". Some sites allow different themes of a single
          skin, and others use different skins for different parts of the
          site.</para>

          <para><emphasis>This problem is typically solved with include files
          and logic to switch between files.</emphasis></para>

          <para>PHOCOA has a complete infrastructure for skinning built into
          the framework. A web application can have an unlimited number of
          skin setups for different parts of the site. Additionally, each of
          these skin setups can have an unlimited number of skins with an
          unlimited number of sub-themes. Skins in PHOCOA are completely
          arbitrary and impose absolutely no design restrictions.</para>

          <para>The undlerlying skin mechanism also allows you to easily
          customize HEAD information such as title and meta tags.</para>

          <para>PHOCOA also includes a menu system infrastructure for managing
          hierachical menu systems.</para>
        </listitem>

        <listitem>
          <para>Maintaining State of a Form Between Requests.</para>

          <para>A nice web application will keep track of all of the data the
          user has entered into the form. In the case that the form's action
          cannot be completed due to validation or other error, the form will
          need to be re-displayed, and it sure is nice if it looks the same as
          when the user pressed "Submit".</para>

          <para><emphasis>This problem is typically solved by a lot of glue
          code, or with tools like HTML_QuickForm or
          patForms.</emphasis></para>

          <para>PHOCOA provides a complete UI state-maintainance mechanism. A
          full set of widgets are provided that represent all HTML input
          types. Each widget automatically maintains its own state. It is also
          possible to create custom widgets to promote re-use of complex
          widgets such as color pickers, date pickers, etc.</para>
        </listitem>

        <listitem>
          <para>Centralized Dispatch Architecture</para>

          <para>Web applications typically have many "actions" that can be
          performed by the user. Developers need a way to easily determine
          which action was requested, and a way to dispatch this action to the
          correct handler.</para>

          <para><emphasis>This problem is typically solved with a Front
          Controller pattern.</emphasis></para>

          <para>PHOCOA implements a Front Controller that locates "modules" in
          unlimited folder structure. PHOCOA also allows your modules to
          access PATH INFO data to promote friendly-URL use.</para>

          <para>PHOCOA is an event-driven architecture as well, automatically
          dispatching control to your action handlers in response to FORM
          submissions.</para>
        </listitem>

        <listitem>
          <para>Request Variable Normalization</para>

          <para>Web applications should take care to prevent XSS (cross-site
          scripting) attacks caused by user manipulation of the request
          data.</para>

          <para><emphasis>This problem is typically solved by writing code to
          filter all incoming data to make sure that it's valid and
          meaningful.</emphasis></para>

          <para>PHOCOA's UI state management only responds to manifested FORM
          parameters, reducing XSS attacks.</para>
        </listitem>

        <listitem>
          <para>Data Validation and Normalization</para>

          <para>Data input to a web application, whether via Path Info or Form
          Submission, needs to be propagated to the model and validated.
          Ideally, you should be able to detect multiple problems at the same
          time to make the site easier to use. At some poin the data must also
          be normalized. The errors must then of course be shown to the
          user.</para>

          <para><emphasis>This problem is typically solved by a number of
          methods: pre-validating data, integrated validation code in model
          components, etc.</emphasis></para>

          <para>PHOCOA provides a complete solution for data validation and
          normalization. A concept called Key-Value Coding provides a common
          infrastructure for writing validation methods on any object.
          Normalization of the data occurs inside the validator. Beyond that,
          the PHOCOA infrastructure provides a centralized location to track
          all errors in a single request. PHOCOA also provides an easy way to
          display these errors in the UI. You can list all errors as well as
          errors for each individual widget.</para>
        </listitem>

        <listitem>
          <para>Web Application Configuration and Deployment</para>

          <para>There are many settings that are application-wide and need to
          be accessible by all parts of the application. This global data can
          be broken down into two types of data: data that is the same whether
          the application is running on a Production or Development server,
          and data that is always needed globally, but changes based on the
          Production/Development status.</para>

          <para><emphasis>Typically this problem is solved by include
          files.</emphasis></para>

          <para>PHOCOA configuration handles both of these situations.
          Application-specific configuration is typically handled by the
          WFWebApplication object via callbacks, and Deployment-specific
          configuration is handled via a conf file.</para>
        </listitem>

        <listitem>
          <para>Session Management</para>

          <para>Sometimes web applications need to keep state across multiple
          requests that is linked to a user's session.</para>

          <para><emphasis>This problem is typically solved using PHP's Session
          API.</emphasis></para>

          <para>PHOCOA doesn't yet provide any session infrastructure.</para>
        </listitem>

        <listitem>
          <para>User Authorization and Authentication</para>

          <para>Many web sites today have a "login" capability. Users can log
          in to access additional functionality or personalization. While the
          specifics of what a logged in user gets vary greatly among
          applications, they all share the need to perform
          authentication.</para>

          <para><emphasis>This problem is typically solved with a special web
          page to perform authentication, followed by keeping track of the
          user in a session context.</emphasis></para>

          <para>PHOCOA has a simple authorization infrastructure that requires
          implementation of only a few methods to login-enable your
          application. A simple interface allows your back-end application to
          use whatever authentication protocol is appropriate. PHOCOA's
          authorization manager also includes support for "Remember Me"
          functionality.</para>
        </listitem>

        <listitem>
          <para>Component Re-Use and Compositing</para>

          <para>Many web applications have "snippets" of functionality that
          need to be re-used througout the site. Search, login, headlines, are
          often self-contained "portlets" of functionality that should be
          re-usable.</para>

          <para><emphasis>This problem is typically solved via
          includes.</emphasis></para>

          <para>PHOCOA provides a rich compositing architecture. Each module
          you create is automatically re-usable in other modules, or in the
          skin itself. PHOCOA provides a variety of compositing and targeting
          capabilities for ushering users through the site.</para>
        </listitem>

        <listitem>
          <para>Data Pagination</para>

          <para>Pagination is the "chunking" of large data sets into smaller
          portions. This prevents a web page from being infinitely long.
          Pagination also typically includes sorting options for the data
          set.</para>

          <para><emphasis>While many data access layers already have
          pagination support, developers are typically left to handle the UI
          portions of pagination on their own.</emphasis></para>

          <para>PHOCOA provides out-of-the-box support for pagination of PHP
          arrays, Propel Criteria-based data sets, and raw SQL data sets via
          Creole. Propel includes several pagination widgets to aid in the
          display of the paginator navigation, and to help with the process of
          switching pages, sorting, etc.</para>
        </listitem>

        <listitem>
          <para>Clean URLS</para>

          <para>Modern web sites need to have clean, simple URLs (i.e., such
          as www.mydomain.com/products/myProduct) to provide a
          easy-to-remember URLs and be search-engine friendly.</para>

          <para><emphasis>This problem is typically solved by parsing the
          PATH_INFO from a URL into your own data structure, then displaying
          the desired page.</emphasis></para>

          <para>PHOCOA's request parameter system makes it easy declare a
          clean URL interface for any page.</para>
        </listitem>

        <listitem>
          <para>AJAX</para>

          <para>Interactive web sites built with AJAX are becoming more
          popular as web users demand that web applications become as
          interactive and responsive as their desktop counterparts.</para>

          <para><emphasis>This problem is typically solved using AJAX
          libraries and writing a lot of JavaScript code and custom PHP pages
          to deliver data.</emphasis></para>

          <para>PHOCOA's AJAX implementation wraps industry standard AJAX
          libraries such as prototype.js and Yahoo's YUI library to make it a
          snap to build rich, interactive web pages.</para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter>
    <title>Getting Started With PHOCOA Programming</title>

    <para>PHOCOA has a very large set of technologies. Because it is based on
    Cocoa (Apple's development infrastructure), if you are a Cocoa programmer
    things will make a lot of sense to you. If you are not familar with Cocoa,
    there is a bit of a learning curve. But trust us, it's worth it. The power
    of PHOCOA will allow you to deliver robust web applications with minimal
    coding in record time.</para>

    <para>Instead of starting off by explaining all of the concepts and
    technologies, we will first walk you through a simple application to show
    you how easy the finished product is. You will be much more motivated to
    learn the concepts when you realize how much time PHOCOA can save
    you.</para>

    <para>This chapter will walk you through the development of a simple
    "Hello, World" application that shows off all of the basic concepts. We
    will explain each concept as simlpy as possible for the example.</para>

    <section>
      <title>Installation and Configuration</title>

      <para>PHOCOA requires that you have the following installed on your
      system:</para>

      <itemizedlist>
        <listitem>
          <para>PHP5</para>
        </listitem>

        <listitem>
          <para>phing</para>
        </listitem>
      </itemizedlist>

      <para>Installing PHP5 is beyond the scope of this documentation.
      Installing phing with the following commands:</para>

      <screen>pear channel-discover pear.phing.info
pear install phing/phing</screen>

      <para>The PHOCOA framework is contained in its own directory. Your
      PHOCOA-based web application will live in its own directory, separate
      from the framework code. This makes it easy to keep the two separated
      for purposes of backup, upgrading, etc.</para>

      <note>
        <para>Eventually we will create a pear channel for installing
        phocoa.</para>
      </note>

      <bridgehead>PHOCOA Directory Structure</bridgehead>

      <para>First let's install the PHOCOA framework. Unpack the PHOCOA
      tarball. The directory structure looks like:</para>

      <screen>$ ls -l phocoa/
total 0
drwxr-xr-x    4 alanpins staff         136 Aug  2 10:34 classes
drwxr-xr-x    5 alanpins staff         170 Oct 15 16:53 conf
drwxr-xr-x    7 alanpins staff         238 Oct 17 14:57 docs
drwxr-xr-x   34 alanpins staff        1156 Oct 17 13:57 framework
drwxr-xr-x    9 alanpins staff         306 Oct 16 12:04 modules
drwxr-xr-x    6 alanpins staff         204 Oct 15 16:50 phing
drwxr-xr-x    4 alanpins staff         136 Aug  2 10:33 skins
drwxr-xr-x    5 alanpins staff         170 Aug  2 10:33 smarty
drwxr-xr-x    5 alanpins staff         170 Aug  2 10:34 wwwroot</screen>

      <para>The <emphasis>classes</emphasis> directory contains a skeleton of
      the basic application infrastructure needed to have a functional
      application. This will be copied to your application's modules directory
      during install.</para>

      <para>The <emphasis>conf</emphasis> directory contains default versions
      of all configuraiton files. These will be copied to your application's
      conf directory during install.</para>

      <para>The <emphasis>docs</emphasis> directory contains a complete PHPDoc
      API reference for the framework. Once you have PHOCOA installed, this
      can be reached from http://your-server.com/docs.</para>

      <note>
        <para>The docs directory shipped with PHOCOA does not include built
        documentation. Use PHPDOC to build the docs with the following
        command. Eventually, this will be set up as a Phing task. The docs are
        also available online at <ulink
        url="http://phocoa.com/docs">http://phocoa.com/docs/</ulink>.</para>

        <screen>$ cd phocoa
$ phpdoc -dn framework-base -t docs/phpdocs -ti "PHOCOA Documentation" -o HTML:frames:default \
--ignore test/ -d framework -f "smarty/plugins/*" -f "conf/webapp.conf"</screen>
      </note>

      <para>The <emphasis>framework</emphasis> directory contains most of the
      framework's code.</para>

      <para>The <emphasis>modules</emphasis> directory contains modules that
      are used by the core framework, or are bundled with the
      framework.</para>

      <para>The <emphasis>phing</emphasis> directory contains the phing
      buildfiles for PHOCOA.</para>

      <para>The <emphasis>skins</emphasis> directory contains bundled skins.
      This is just a single skin, so that your application has some skin when
      it starts. These will be copied to your application's skins directory
      during install.</para>

      <para>The <emphasis>smarty</emphasis> directory is where templates and
      plugins used by the framework go.</para>

      <para>The <emphasis>wwwroot</emphasis> directory is the public wwwroot.
      This wwwroot contains the bootstrapping code for a PHOCOA application
      and a directory for all public www documents.</para>

      <bridgehead>Using <command>phocoa</command> to Start a New
      Project</bridgehead>

      <para>PHOCOA comes with a shell script to help you manage common PHOCOA
      tasks. This script is aptly named <command>phocoa</command>. The phocoa
      command is located at phocoa/phing/phocoa. We recommend that you alias
      it to avoid having to type the entire path each time.</para>

      <para>Let's use <command>phocoa</command> to build a new project.</para>

      <screen>$ phocoa newproject
phing -f /Users/alanpinstein/dev/sandbox/phocoa/phocoa/phing/build.xml -Dusing.phocoa.make=true -Dphocoa.pwd=/Users/alanpinstein/dev/sandbox -Dphocoa.dir=/Users/alanpinstein/dev/sandbox/phocoa/phocoa -Dphocoa.project.name= -Dphocoa.project.dir= newproject
Buildfile: /Users/alanpinstein/dev/sandbox/phocoa/phocoa/phing/build.xml

phocoa &gt; prepareGeneral:
     [echo] PHOCOA framework base dir at: /Users/alanpinstein/dev/sandbox/phocoa/phocoa

phocoa &gt; newproject:
Enter the name of the new project: [] helloworld
Enter the path to create the new project in: [/Users/alanpinstein/dev/sandbox] 
[realpathexpandhome] Resolved /Users/alanpinstein/dev/sandbox/helloworld to /Users/alanpinstein/dev/sandbox/helloworld
Enter the name of the server (ie dns name) that will host this application: [localhost] 
Enter the IP of the server that will host this application: [127.0.0.1] 
Enter the PORT of the server that will host this application: [80] 
[phingcall] Calling Buildfile '/Users/alanpinstein/dev/sandbox/phocoa/phocoa/phing/build.xml' with target 'setupProjectContainer'

phocoa &gt; setupProjectContainer:
     [echo] Creating project container directories and setting up permissions
    [mkdir] Created dir: /Users/alanpinstein/dev/sandbox/helloworld
    [mkdir] Created dir: /Users/alanpinstein/dev/sandbox/helloworld/log
    [chmod] Changed file mode on '/Users/alanpinstein/dev/sandbox/helloworld/log' to 777
    [mkdir] Created dir: /Users/alanpinstein/dev/sandbox/helloworld/runtime
    [chmod] Changed file mode on '/Users/alanpinstein/dev/sandbox/helloworld/runtime' to 777
    [mkdir] Created dir: /Users/alanpinstein/dev/sandbox/helloworld/runtime/smarty/templates_c
    [chmod] Changed file mode on '/Users/alanpinstein/dev/sandbox/helloworld/runtime/smarty/templates_c' to 777
     [echo] Creating project directory: /Users/alanpinstein/dev/sandbox/helloworld/helloworld
    [mkdir] Created dir: /Users/alanpinstein/dev/sandbox/helloworld/helloworld
     [echo] Copying PHOCOA templates...
     [copy] Copying 9 files to /Users/alanpinstein/dev/sandbox/helloworld/helloworld
    [mkdir] Created dir: /Users/alanpinstein/dev/sandbox/helloworld/helloworld/wwwroot/www
    [mkdir] Created dir: /Users/alanpinstein/dev/sandbox/helloworld/helloworld/modules
     [echo] Setting up configuration files...
     [copy] Copying 3 files to /Users/alanpinstein/dev/sandbox/helloworld/helloworld
[filter:ReplaceTokens] Replaced "##SERVER_IP##" with "127.0.0.1"
[filter:ReplaceTokens] Replaced "##SERVER_PORT##" with "80"
[filter:ReplaceTokens] Replaced "##SERVER_NAME##" with "localhost"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_BASE_DIR##" with "/Users/alanpinstein/dev/sandbox/phocoa/phocoa"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_BASE_DIR##" with "/Users/alanpinstein/dev/sandbox/phocoa/phocoa"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_CONTAINER_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_CONTAINER_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_BASE_DIR##" with "/Users/alanpinstein/dev/sandbox/phocoa/phocoa"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_CONTAINER_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_CONTAINER_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld"
[filter:ReplaceTokens] Replaced "##PHOCOA_APP_DIR##" with "/Users/alanpinstein/dev/sandbox/helloworld/helloworld"
[phingcall] Calling Buildfile '/Users/alanpinstein/dev/sandbox/phocoa/phocoa/phing/build.xml' with target 'httpdconf'

phocoa &gt; prepareGeneral:
     [echo] PHOCOA framework base dir at: /Users/alanpinstein/dev/sandbox/phocoa/phocoa

phocoa &gt; prepareProject:
     [echo] 1
      [php] Evaluating PHP expression: $_ENV['_']
     [echo] PHOCOA project dir at: /Users/alanpinstein/dev/sandbox/helloworld/helloworld
[realpathexpandhome] Resolved /Users/alanpinstein/dev/sandbox/helloworld/helloworld/.. to /Users/alanpinstein/dev/sandbox/helloworld
     [echo] PHOCOA project container dir at: /Users/alanpinstein/dev/sandbox/helloworld
 [property] Loading /Users/alanpinstein/dev/sandbox/helloworld/helloworld/conf/build.properties
 [property] Unable to find property file: /Users/alanpinstein/dev/sandbox/helloworld/helloworld/conf/build.properties... skipped

phocoa &gt; httpdconf:
     [echo] PHOCOA requires some httpd configurations to work its magic. You must either be able to edit httpd.conf, or have an apache with mod_rewrite enabled.
Select httpd configuration mode: 1=httpd.conf, 2=.htaccess [1] 
     [echo] Make sure your httpd.conf file contains the line: Include /Users/alanpinstein/dev/sandbox/helloworld/helloworld/helloworld/conf/httpd.conf
Will this project use database access via Propel?(yes/no) [1] no
     [echo] New Project setup complete.

BUILD FINISHED

Total time: 8.7973 seconds
</screen>

      <para>You should now have a directory <emphasis>helloworld</emphasis>
      containing your new PHOCOA application.<emphasis></emphasis></para>

      <screen>$ ls -l helloworld                                                                                                                                           alanpinstein@g5:~/dev/sandbox
total 0
drwxr-xr-x    7 alanpins staff         238 Oct 17 15:03 helloworld
drwxrwxrwx    2 alanpins staff          68 Oct 17 15:02 log
drwxrwxrwx    3 alanpins staff         102 Oct 17 15:02 runtime</screen>

      <para>This directory contains your PHOCOA deployment structure.
      Typically, log and runtime (tmp / cache) files are not part of your
      source code, so PHOCOA sets up a wrapper directory containing these
      items.</para>

      <para>The <emphasis>helloworld</emphasis> directory inside of this
      deployment structure is your PHOCOA applications directory.</para>

      <para><note>
          <para>This "inner" directory is the root directory of your PHOCOA
          application code, and is what you should check in to your version
          control system. The log/ and runtime/ directories are not versioned
          resources, thus we keep them one level up in the directory structure
          for organizational purposes.</para>
        </note></para>

      <bridgehead>Application Directory Structure</bridgehead>

      <para>Now let's have a look at the directory structure.</para>

      <screen>$ ls -l helloworld/helloworld
total 20
drwxrwxr-x  3 alanpins staff 4096 May 31 07:35 classes
drwxrwxr-x  2 alanpins staff 4096 May 31 11:12 conf
drwxrwsr-x  9 alanpins staff 4096 May 30 15:53 modules
drwxrwxr-x  5 alanpins staff 4096 May 30 18:14 skins
drwxrwxr-x  3 alanpins staff 4096 May 31 09:00 wwwroot</screen>

      <para>The <emphasis>classes</emphasis> directory is where all of your
      classes go. These are classes specific to your application.</para>

      <para>The <emphasis>conf</emphasis> directory contains all configuraiton
      files.</para>

      <para>The <emphasis>modules</emphasis> directory is where all components
      go. These components are the building blocks of your application and
      include both entire pages and sub-components.</para>

      <para>The <emphasis>skins</emphasis> directory is where all skins
      go.</para>

      <para>The <emphasis>wwwroot</emphasis> directory is a public wwwroot
      that contains the front controller for the PHOCOA project. All public
      documents (i.e. the tradiditional public www root) go in
      wwwroot/www/.</para>

      <bridgehead>Initial Configuration</bridgehead>

      <para>First thing to do is configure the framework.</para>

      <screen>$ ls -l helloworld/helloworld/conf
total 24
-rw-r--r--   1 alanpins  staff  1272 May 18 14:24 httpd.conf
-rw-r--r--   1 alanpins  staff  1561 May 18 12:58 webapp.conf</screen>

      <para>The httpd.conf file is the Apache configuration for your
      application. You should customize it to match your domain and path to
      where you put PHOCOA. Most of this was done automatically by the Phing
      <emphasis>newproject</emphasis> build. Examine the file to be sure it
      matches what you want. You can of course make any corrections to
      mistakes you may have made earlier regarding hostname, port, etc. Also,
      examine the WebDAV setup (optional - feel free to comment this out if
      you don't have or want WebDAV access). We assume that you are familiar
      with apache setup.</para>

      <note>
        <para>WebDAV can be useful when working on an application remotely.
        Since PHOCOA includes a Mac OS X application to graphically manage
        some configuration files, using WebDAV enables you to use the PHOCOA
        Builder Application on your computer, but working on a PHOCOA
        application directory on a remote computer. For this reason, you need
        only share the "modules" directory of your webapp.</para>
      </note>

      <para>Then, include your application's httpd configuration file in your
      main httpd.conf like so:</para>

      <programlisting>Include /path/to/helloworld/helloworld/conf/httpd.conf</programlisting>

      <para>Now restart Apache.</para>

      <para>Next up is the PHOCOA conf file. Open up webapp.conf. Read through
      it, setting up each directive as explained by the comments. It should
      also be set up correctly because of the Phing task. You may need to
      tweak the PHP include_path setting to ensure that PHOCOA can see your
      smarty install.</para>

      <para>At this point, you should be able to access the site via the web.
      You should be able to access the application via
      http://servername/.</para>

      <para>Now, we can move on to the tutorial!</para>
    </section>

    <section>
      <title>Module / Page Component Architecture</title>

      <bridgehead>Modules</bridgehead>

      <para>The basic unit of work in a PHOCOA application is the module. A
      module is a collection of views and code related to a single function.
      It is conceptually the same as a single PHP file in a traditional PHP
      application. There may be multiple actions, web pages, etc, but it's all
      stored in one file.</para>

      <para>Each PHOCOA module is a single PHP file that contains a single
      WFModule subclass. There is a naming convention to the subclass names.
      The subclass should be named "module_&lt;dirName&gt;" where
      &lt;dirName&gt; is the name of the directory that the module sits in.
      This helps prevent name collisions with other classes. This subclass
      will have specially named functions that you create to set up pages and
      respond to user actions.</para>

      <para>Because each module has multiple pages, actions, etc., each module
      in PHOCOA is essentially a reusable web component. The components can be
      used one-at-a-time to build complete pages, or you can composite modules
      together to create complex layouts and behaviors.</para>

      <para>Modules are invoked via an <property>invocationPath</property>
      which looks like
      <property>path/to/module/pageName/param1/param2</property>. Obviously
      this looks a lot like a URL. When you go to a URL of a PHOCOA
      application, the request controller parses out the
      <property>invocationPath</property> from the URL and executes the
      module. Modules that include other modules simply supply the
      <property>invocationPath</property> directly.</para>

      <bridgehead>Pages</bridgehead>

      <para>Each module can contain an arbitrary number of pages. A page is
      simply a single web view that a user can see. You can think of it as a
      web page, a view, a screen, whatever works for you. For instance, you
      may have one view that is an input form, and another view that is used
      for telling the user the form's action succeeded.</para>

      <bridgehead>Actions</bridgehead>

      <para>Each page has a number of actions. Actions are trigger by the user
      submitting a form. When the user submits a form, PHOCOA will hand off
      control to an action handler in your module where you can respond to the
      action.</para>

      <para>It should be noted that not all requests have actions. It is
      possible to just load a page in a module WITHOUT an action. In this
      case, the module can display the default page, or could look in the
      parameters passed to it to find information used to load default data
      into the page.</para>
    </section>

    <section>
      <title>Building "Hello, World!"</title>

      <para>Let's put PHOCOA to work with a simple example. We will start out
      by creating a new module, "helloworld".</para>

      <para>First, cd into the modules subdirectory.</para>

      <screen>$ cd helloworld/helloworld/modules</screen>

      <para>To create a new module, we have a <command>phocoa</command>
      command to help us:</para>

      <screen>$ phocoa createModule
phing -f /Users/alanpinstein/dev/sandbox/phocoa/phocoa/phing/build.xml -Dusing.phocoa.make=true -Dphocoa.pwd=/Users/alanpinstein/dev/sandbox/helloworld/helloworld/modules -Dphocoa.dir=/Users/alanpinstein/dev/sandbox/phocoa/phocoa -Dphocoa.project.name=helloworld -Dphocoa.project.dir=/Users/alanpinstein/dev/sandbox/helloworld/helloworld createModule
Buildfile: /Users/alanpinstein/dev/sandbox/phocoa/phocoa/phing/build.xml

phocoa &gt; prepareGeneral:
     [echo] PHOCOA framework base dir at: /Users/alanpinstein/dev/sandbox/phocoa/phocoa

phocoa &gt; prepareProject:
     [echo] 1
      [php] Evaluating PHP expression: $_ENV['_']
     [echo] PHOCOA project dir at: /Users/alanpinstein/dev/sandbox/helloworld/helloworld
[realpathexpandhome] Resolved /Users/alanpinstein/dev/sandbox/helloworld/helloworld/.. to /Users/alanpinstein/dev/sandbox/helloworld
     [echo] PHOCOA project container dir at: /Users/alanpinstein/dev/sandbox/helloworld
 [property] Loading /Users/alanpinstein/dev/sandbox/helloworld/helloworld/conf/build.properties
 [property] Unable to find property file: /Users/alanpinstein/dev/sandbox/helloworld/helloworld/conf/build.properties... skipped

phocoa &gt; createModule:
Module name: helloworld
Default page [blank for none]: helloworld
     [exec] Executing command: /opt/local/bin/php /Users/alanpinstein/dev/sandbox/phocoa/phocoa/framework/createModule.php helloworld helloworld 2&gt;&amp;1
     [exec] Writing helloworld/helloworld.php
     [exec] Done building module helloworld!
     [exec] Writing helloworld.tpl
     [exec] Writing helloworld.yaml
     [exec] Done!

BUILD FINISHED

Total time: 9.0093 seconds
</screen>

      <para>The createModule command automatically creates a new module with a
      single page.</para>

      <para><programlisting>class module_helloworld extends WFModule
{
    /**
      * Tell system which page to show if none specified in the URL. 
      */ 
     function defaultPage()
     {
         return 'helloWorld';
     }
}</programlisting></para>

      <para>WFModule is an abstract class, requiring only one method,
      "defautPage()". This method simply tells the system what page to load if
      none is specified.</para>

      <para>Next, let's examine the helloworld page.</para>

      <para>Each page in PHOCOA has two parts. The .tpl file (the HTML Smarty
      template), and the .yaml file (contains a list of all instances used in
      the template, along with their configuration). PHOCOA needs a list of
      all UI instances used in the view so that it can work its magic in
      maintaining state, etc. The .yaml file is used to configure each widget
      by specifying properties, for instance by specifying labels, sizes,
      formatters, and other attributes. The .yaml file is also used to set up
      Bindings, which is how PHOCOA links UI widget data to your model. Don't
      worry about these details for now, though; we'll explain further as we
      go along.</para>

      <para>PHOCOA includes a Phing task to add a page to an existing module
      as well. This script should be run from inside the module directory that
      you want to add the page to.</para>

      <screen>$ phocoa createPage
phing -f /Users/alanpinstein/dev/sandbox/phocoa/phocoa/phing/build.xml -Dusing.phocoa.make=true -Dphocoa.pwd=/Users/alanpinstein/dev/sandbox/helloworld/helloworld/modules/helloworld -Dphocoa.dir=/Users/alanpinstein/dev/sandbox/phocoa/phocoa -Dphocoa.project.name=helloworld -Dphocoa.project.dir=/Users/alanpinstein/dev/sandbox/helloworld/helloworld createPage
Buildfile: /Users/alanpinstein/dev/sandbox/phocoa/phocoa/phing/build.xml

phocoa &gt; prepareGeneral:
     [echo] PHOCOA framework base dir at: /Users/alanpinstein/dev/sandbox/phocoa/phocoa

phocoa &gt; prepareProject:
     [echo] 1
      [php] Evaluating PHP expression: $_ENV['_']
     [echo] PHOCOA project dir at: /Users/alanpinstein/dev/sandbox/helloworld/helloworld
[realpathexpandhome] Resolved /Users/alanpinstein/dev/sandbox/helloworld/helloworld/.. to /Users/alanpinstein/dev/sandbox/helloworld
     [echo] PHOCOA project container dir at: /Users/alanpinstein/dev/sandbox/helloworld
 [property] Loading /Users/alanpinstein/dev/sandbox/helloworld/helloworld/conf/build.properties
 [property] Unable to find property file: /Users/alanpinstein/dev/sandbox/helloworld/helloworld/conf/build.properties... skipped

phocoa &gt; createPage:
Page Name: test
     [exec] Executing command: /opt/local/bin/php /Users/alanpinstein/dev/sandbox/phocoa/phocoa/framework/createPage.php test 2&gt;&amp;1
     [exec] Writing test.tpl
     [exec] Writing test.yaml
     [exec] Done!

BUILD FINISHED

Total time: 1.6136 second</screen>

      <para>Now, edit the helloWorld.tpl file with a classic message:</para>

      <para><programlisting>Hello, World! </programlisting></para>

      <para>That's all that's needed to make a simple web page in PHOCOA.
      Simply load up the URL for this page: http://localhost/helloworld and
      you should see the helloworld page!</para>
    </section>

    <section>
      <title>Forms</title>

      <para>One of PHOCOA's biggest benefits is that it automatically
      maintains state of all GUI widgets across requests. Without any code at
      all, you can have an arbitraily complex form which automatically
      remembers all values perfectly from one request to another. PHOCOA also
      has integrated data validation and error handling that keep track of
      errors on a field-by-field basis. Thus, PHOCOA greatly simplifies the
      creation of user-friendly forms that automatically remember their state
      and show errors on a per-field basis.</para>

      <para>Our next task will be to create a form.</para>

      <para>PHOCOA uses smarty as its template language. We've included a
      number of extra smarty tags for use with PHOCOA.</para>

      <para>Create the following in your helloworld.tpl to build a simple
      email form:</para>

      <programlisting>
        {WFForm id="form"} 
        To Email: {WFTextField id="email"}
        {WFSubmit id="submit"} 
        {/WFForm} 
      </programlisting>

      <para>PHOCOA requires that all widgets be declared in the
      "configuration" for each page. The configuration for the page is stored
      in the .yaml file corresponding to the tpl file, so in this case, it's
      helloworld.yaml.</para>

      <para>Let's declare these three widgets.</para>

      <note>
        <para>The .yaml files use a language call YAML to configure the data.
        YAML is an excellent human-readable, human-editable configuration
        language.</para>
      </note>

      <para><tip>
          <para>If you're using Mac OS X Tiger, you can use the PHOCOA Builder
          application to manage the .yaml files graphically.<screenshot>
              <screeninfo>PHOCOA Builder</screeninfo>

              <mediaobject>
                <imageobject>
                  <imagedata fileref="img-pb1.jpg" />
                </imageobject>
              </mediaobject>
            </screenshot></para>
        </tip>The end result should be that the helloWorld.yaml file looks
      like:</para>

      <programlisting>form: 
  class   : WFForm
  children: 
    email  : 
      class: WFTextField
    submit : 
      class: WFSubmit</programlisting>

      <para>The format of the .yaml file is a nested array of instances by ID.
      Each instance must have a class attribute. Each instance may also have
      <property>properties</property>, <property>bindings</property>, or
      <property>children</property> attributes. The chidren attribute contains
      more of the same, to build a nested structure of instances.</para>

      <para>When PHOCOA processes the .yaml file, it will create an instance
      of the given class for the given ID. The rest of the system then can
      interact with the widgets by ID. In code, you can access a widget
      with:</para>

      <programlisting> $myTextField = $page-&gt;outlet('MyTextFieldInstanceID');</programlisting>

      <para>So, what action gets run when the user submits this form? The
      action methods are simply specially named methods of the WFModule
      subclass. Here's the prototype:</para>

      <para><function>&lt;pageName&gt;_&lt;actionID&gt;_Action($requestPage)</function></para>

      <para>So, we now need to define a function in our WFModule subclass to
      run when the submit button is clicked. Add this to the helloworld.php
      file:</para>

      <programlisting> function helloWorld_submit_Action($page) {} </programlisting>

      <para>For now, our action method won't do anything. However, we have to
      declare it or the framework will throw an exception when we press the
      corresponding button.</para>

      <para>So, now load the page again and you should see a form. Enter in
      some data and press the submit button. You will notice that the form
      will be re-displayed with the data you entered still there. This is a
      simplified example of PHOCOA's state-maintenance capabilities. Any form
      elements that are added will automatically have their state maintained.
      All HTML form elements are available.</para>
    </section>

    <section>
      <title>Data</title>

      <para>While it's somewhat interesting to see the form maintain its
      state, it's not particularly useful on its own. Typically a form
      submission will need to do something, and typically that will involve
      moving the data from the form to an object, validating the data, and
      eventually performing an action. Sometimes, you'll also need to format
      the data in a more human-readable way than it is stored, for instance,
      timestamps.</para>

      <para>The glue layer between the GUI and the model is a huge benefit of
      PHOCOA. Based on Apple's Controller Layer, PHOCOA automates the process
      of moving data between the GUI elements and the data layer. Instead of
      writing code to move the data between the layers, the PHOCOA controller
      layer does this automatically. All you have to do is configure the GUI
      elements to "bind" them to your model objects. This is done without any
      coding, and once it's done, the controller layer automatically keeps
      your GUI in sync with your data as well as automatically providing data
      validation and error handling.</para>

      <para>To extend our example and really explore PHOCOA, we're going to
      build a classic web application, a form-to-email page.</para>

      <para>First, let's define our new class, ExampleEmail. Normally each
      class is stored in its own file, but for simplicity, we'll just put our
      ExampleEmail class in helloworld.php. Add the following:</para>

      <programlisting>
        class ExampleEmail extends WFObject 
        { 
             protected $toEmail; 
             protected $subject; 
             protected $message;
            
             function send()
             {
                 $sent = mail( $this-&gt;toEmail, $this-&gt;subject, $this-&gt;message );
                 return $sent;
             }
        } 
      </programlisting>

      <para>Now, of course, we also need a bigger form, so edit
      helloWorld.tpl:</para>

      <programlisting>
        {WFForm id="form"} 
             Email: {WFTextField id="email"}&lt;br /&gt;
             Subject: {WFTextField id="subject"}&lt;br /&gt;
             Message: {WFTextArea id="message"}&lt;br /&gt;
             {WFSubmit id="submit"} 
        {/WFForm} 
      </programlisting>

      <para>Since we've added components to the page, we need to declare them
      in the helloworld.yaml file, which should now look like:</para>

      <programlisting>form: 
  class   : WFForm
  children: 
    email  : 
      class: WFTextField
    message: 
      class: WFTextArea
    subject: 
      class: WFTextField
    submit : 
      class: WFSubmit</programlisting>

      <para>Now, of course we need to link the form elements to our new
      ExampleEmail class. This is where PHOCOA starts to get really
      interesting. You won't have to write ANY code to make this
      happen!</para>

      <para>First off, we will need an instance of the ExampleEmail class,
      right? Well, just like there is the helloWorld.yaml file, there is also
      a mechanism for instantiating objects for the module. These are called
      Shared Instances, and they are conceptually similar to instantiating
      objects in a nib file in Cocoa. You create a shared.yaml file, and
      instantiate and configure those instances there. All instances declared
      in shared.yaml will be created automatically when your module is
      initialized.</para>

      <para>So, let's set up an ExampleEmail instance! Create a file called
      shared.yaml, and enter the following:</para>

      <programlisting>email: 
  class: ExampleEmail</programlisting>

      <para>Of course, once again if you're on Mac OS X Tiger, you can use
      PHOCOA Builder to create a shared instance. Simply press the "Add"
      button in the "Shared Instances" area and enter in the instance ID and
      class.</para>

      <para>Now we are guaranteed to have an instance of ExampleEmail set up
      as an instance variable of our helloworld class.</para>

      <note>
        <para>Shared instances are simply instance variables of the module
        class. Thus, you can access the email instance we've just created in
        your module code via <code>$this-&gt;email</code>.</para>
      </note>

      <para>Next up, we need to link the form elements to the members of our
      ExampleEmail class. For this, we need to introduce a concept called
      Bindings. Bindings are a way to link the property of one class to the
      property of another class.</para>

      <para><tip>
          <para>If you're familiar with COCOA, these work very similarly to
          bindings in Cocoa, with the small difference that in PHOCOA the
          bindings are not implemented with a real-time observer pattern.
          Since PHP is stateless, we decided to simply push values from
          bindings once at the beginning of the request cycle, and pull values
          from bindings once at the end of the request cycle, just before
          rendering.</para>
        </tip></para>

      <para>So, to set up the bindings we're going to edit the helloWorld.yaml
      file, to the following:</para>

      <para><programlisting>form: 
  class   : WFForm
  children: 
    email  : 
      bindings: 
        value: 
          instanceID  : email
          modelKeyPath: toEmail
      class   : WFTextField
    message: 
      bindings: 
        value: 
          instanceID  : email
          modelKeyPath: message
      class   : WFTextArea
    subject: 
      bindings: 
        value: 
          instanceID  : email
          modelKeyPath: subject
      class   : WFTextField
    submit : 
      class: WFSubmit</programlisting></para>

      <note>
        <para>Once again, if you're using PHOCOA Builder, you can do this
        graphically. Note that PHOCOA Builder has pick-lists for many of the
        fields to help you with the process. Also, when you add a binding,
        PHOCOA Builder guesses that you want to bind to the currently selected
        shared instance, and uses the ID of the page instance as the model key
        for the binding. Thus, if you make the ID's of the page instances the
        same as the property names you will bind to, PHOCOA Builder saves you
        time by pre-selecting the correct binding settings.</para>
      </note>

      <para>To explain what's happening here, let's look at subject first. We
      create a 'bindings' key for 'subject', and declare that we want to bind
      the "value" property of the "subject" instance (which is a WFTextField).
      We want to bind the "value" property to the "email" instance variable of
      our helloworld class, and we want to link it to the "subject" property
      of the "email" instance. For now, don't worry about the
      controllerKey.</para>

      <para>What is a modelKeyPath? Let's introduce another concept that we
      call Key-Value Coding. This again will be familiar to Cocoa developers.
      Basically, the idea is that classes have a number of properties (their
      members / instance variables). Key-Value Coding provides a generic
      mechanism for accessing or mutating these members. This is very similar
      to the __get() and __set() capabilities in PHP5. The following generic
      functions:</para>

      <para><programlisting>function valueForKey($key);
function setValueForKey($value, $key);</programlisting></para>

      <para>provide access to get/set any properties of classes derived from
      WFObject. If you'll remember, our ExampleEmail class extends WFObject,
      and this is why.</para>

      <para>So, we can call:</para>

      <para><programlisting>$email-&gt;setValueForKey('Test Message', 'subject')</programlisting></para>

      <para>and this will update the subject of our exampleEmail class. The
      binding that we've just configured will now do this for you
      automatically. It will also take its value from the email instance, if
      there is one. The same is also true for the <property>message</property>
      and <property>email</property> fields.</para>

      <para>The <function>valueForKey</function> /
      <function>setValueForKey</function> functions try a variety of
      approaches to access the property's data. First, they will use accessors
      with a particular naming convention: <function>&lt;key&gt;() or
      get&lt;Key&gt;(),</function> and <function>set&lt;Key&gt;()</function>
      where &lt;key&gt; is the property name. For instance,
      <function>emailTo()</function> would be used as the accessor for the
      <property>emailTo</property> member, and
      <function>setEmailTo($value)</function> for the mutator. If these
      specially named accessors are not available, the system will try to
      access the member directly.</para>

      <para>One last thing before we try it out. Of course, we need to have
      our action handler call the send() method on our email instance when the
      form is submitted, right? So, modify the action handler to the
      following:</para>

      <programlisting>function helloWorld_submit_Action($page)
{
    $this-&gt;email-&gt;send();
}</programlisting>

      <para>As mentioned previously, because of the setup we did in
      shared.yaml, we're guaranteed to have an instance variable in our
      helloworld class populated with an ExampleEmail instance. So we need
      only to tell it to send!</para>

      <para>Your mailer should work now. Try it out by sending an email to
      yourself. Assuming your mailer setup for PHP is correct, you should get
      an email!</para>
    </section>

    <section>
      <title>Responding With a Different Page</title>

      <para>At the end of the last section, we had a working mailer. However,
      the UI didn't change when the user submitted the form. Probably we'll
      want to display a "success" message when the mail is sent. Let's walk
      through the steps to display a different page as a response to an
      action.</para>

      <para>First, let's create the success page. Use the handy
      <command>phocoa createPage</command> command (run this command from
      inside the helloworld module directory) to create a page named
      "emailSuccess", then edit the template to look like this:</para>

      <programlisting>&lt;p&gt;Successfully sent email!&lt;/p&gt;
To: {WFLabel id="email"}&lt;br /&gt; 
Subject: {WFLabel id="subject"}&lt;br /&gt; 
Message: {WFLabel id="message"}</programlisting>

      <para>Now, set up the emailSuccess.yaml:</para>

      <note>
        <para>If you're using PHOCOA Builder, you'll need to close and re-open
        the module since PHOCOA Builder doesn't recognize when a new page is
        created while the module is open.</para>
      </note>

      <programlisting>email  : 
  bindings: 
    value: 
      instanceID  : email
      modelKeyPath: toEmail
  class   : WFLabel
message: 
  bindings: 
    value: 
      instanceID  : email
      modelKeyPath: message
  class   : WFLabel
subject: 
  bindings: 
    value: 
      instanceID  : email
      modelKeyPath: subject
  class   : WFLabel</programlisting>

      <para>Now, in the our action handler, we want to show the success page
      if the email was sent, so we add a line to set up the reponse page to
      use:</para>

      <programlisting>function helloWorld_submit_Action($page)
{
    $this-&gt;email-&gt;send();
    $this-&gt;setupResponsePage('emailSuccess');
}</programlisting>

      <para>Try submitting the email form again. This time, you should see the
      success page you've just created.</para>
    </section>

    <section>
      <title>Validating data</title>

      <para>Let's add some validation to our email class. For instance, let's
      say that we want to require a properly-formatted email address, and the
      subject cannot be blank. Of course, we'll also want to show the errors
      to the user. How to accomplish this with PHOCOA?</para>

      <para>It's time once again to introduce another concept: Key-Value
      Validation. Similar to Key-Value coding, the Key-Value Validation
      mechanism looks for specially-named functions of your class, with the
      following prototype:</para>

      <para><programlisting>boolean validate&lt;Key&gt;(&amp;$value, &amp;$edited, &amp;$errors)</programlisting></para>

      <para>It is very important to notice the pass-by-reference used on all
      three parameters.</para>

      <para>So, we can implement our two validators by adding the following
      code to ExampleEmail:</para>

      <programlisting>
    function validateToEmail(&amp;$value, &amp;$edited, &amp;$errors)
    {
        $value = trim($value);
        $edited = true;
        if (preg_match("/[A-z0-9._-]+@[A-z0-9-]+\.[A-z0-9-\.]*[A-z]+$/", $value) == 1) return true;

        $errors[] = new WFError("The email you entered is not a properly formatted email address.");
        return false;
    }

    function validateSubject(&amp;$value, &amp;$edited, &amp;$errors)
    {   
        $value = trim($value);
        $edited = true;
        if ($value != '') return true;

        $errors[] = new WFError("The subject cannot be blank.");
        return false;
    }</programlisting>

      <para>Validators in PHOCOA are a bit different than some validation
      mechanisms. Validators are called BEFORE the actual value is set, by the
      Bindings system, as a pre-flight mechanism. Doing it this way prevents
      invalid data from ever being in the class.</para>

      <para>The validators can also do normalization of the data. Since the
      value is passed by reference, you can normalize the data in any
      appropriate way. If you do alter the data, be sure to set edited to
      true.</para>

      <para>Notice also that the errors parameter is an array. This allows you
      to specify multiple errors during validation.</para>

      <para>Now that we can detect errors, we'll want to display the errors to
      the user as well, so let's edit the helloWorld.tpl file:</para>

      <programlisting>
{WFShowErrors}

{WFForm id="form"}
    Email: {WFTextField id="email"}&lt;br /&gt; {WFShowErrors id="email"}
    Subject: {WFTextField id="subject"}&lt;br /&gt; {WFShowErrors id="subject"}
    Message: {WFTextArea id="message"}&lt;br /&gt;
    {WFSubmit id="submit"}
{/WFForm}
      </programlisting>

      <para>You'll notice the addition of several {WFShowErrors} tags. This is
      a special function that looks up the errors generated by the specified
      widget ID and dislpays them. If no id is specified, all errors will be
      displayed.</para>

      <para>Now try the form again, but this time enter invalid data for both
      the Email and Subject fields and then submit. You'll see that all of the
      errors are listed above the form, and the specific errors are again
      repeated next to the relevant form elements.</para>

      <para>PHOCOA performs all validation as it is moving the data to your
      objects via bindings. If the validation fails at all, then the "action"
      method will not be called. Sometimes of course, there will be no during
      the bindings phase, but errors may still occur when processing the
      action. For instance, saving data to a database might return an error.
      In this case, you can easily add additional errors using the addError()
      function of WFPage.</para>
    </section>

    <section>
      <title>Formatting Data</title>

      <para>There's one more major component to the PHOCOA framework that you
      should know about, and that's Formatters. Many data types are not
      human-readable by default, or are not in the desired format. Good
      examples are timestamps and number formats.</para>

      <para>We'll now extend our example to show off formatters.</para>

      <para>Let's add a timestamp to our ExampleEmail class:</para>

      <para><programlisting> protected $sendTimestamp; </programlisting></para>

      <para>and in the send() method:</para>

      <para><programlisting> $this-&gt;sendTimestamp = time(); </programlisting></para>

      <para>Now, let's add the date sent to the success page:</para>

      <para><programlisting>Date Sent: {WFLabel id="timestamp"}&lt;br /&gt;
      </programlisting></para>

      <para>And now of course we need to add it to emailSuccess.yaml, and also
      set up the binding:</para>

      <programlisting>timestamp: 
  bindings: 
    value: 
      instanceID  : email
      modelKeyPath: sendTimestamp
  class   : WFLabel</programlisting>

      <para>If you try sending another email now, you'll see that the Date
      Sent is an ugly integer, or UNIX time. To format it, we can use a PHOCOA
      formatter. Formatters are special PHOCOA classes that help with
      converting data between the way your model stores a value and a
      human-readable form of the same value. WFFormatter subclasses do the
      actual work; PHOCOA provides the following subclasses:
      WFNumberFormatter, WFSQLDateFormatter, and WFUNIXDateFormatter. You can
      add your own formatters if you like. We want to use a
      WFUNIXDateFormatter.</para>

      <para>To add a formatter, you could instantiate one manually in the
      helloworld.php file, and then link it to the timestamp label. However,
      why bother coding if you don't have to? Let's instantiate a
      WFUNIXDateFormatter by adding some code in shared.yaml. You can also set
      up your own format string, by using shared.yaml to set up the
      formatString property of the WFUNIXDateFormatter instance.
      WFUNIXDateFormatter simply wraps PHP's <function>date()</function>
      function, using "r" by default as the format string. Here's what it
      looks like:</para>

      <para><programlisting>dateSentFormatter: 
  class     : WFUNIXDateFormatter
  properties: 
    formatString: F j, Y, g:i a</programlisting><note>
          <para>In PHOCOA Builder, you can configure properties of a shared
          instance by selecting the shared instance and editing properties in
          the "Shared Instance Inspector."</para>
        </note></para>

      <para>Now, we want to make the timestamp label use the formatter.
      There's another feature of the .yaml files besides bindings; you can use
      them to set up properties of the instances. Supply a property name and
      value, and PHOCOA will configure that property with a
      <function>setValueForKey()</function> call.</para>

      <para>So, in emailSuccess.yaml, we can set the "formatter" property to
      the formatter we instantiated in shared.yaml by editing the 'timestamp'
      entry:</para>

      <programlisting>timestamp: 
  bindings  : 
    value: 
      instanceID  : email
      modelKeyPath: sendTimestamp
  class     : WFLabel
  properties: 
    formatter: '#module#dateSentFormatter'</programlisting>

      <para>Notice the #module# preceding the shared instance ID; since you
      can use the config mechanism to set up values such as strings, integers,
      booleans, and doubles, we needed a special flag to indicate that you
      want to link it to the value of an instance variable of the module,
      which is what shared instances are.</para>

      <para>Another note, formatters are reversible. So, if you have a date
      field that you want to be editable, feel free to add a formatter to a
      WFTextField instance. The formatter will attempt to convert the edited
      string value using PHP's <function>strtotime()</function> function. In
      this case, you might want to add a validator to your date property to
      make sure it's not NULL, which is what you'll get if the string was not
      parseable by <function>strtotime().</function></para>
    </section>

    <section>
      <title>Compositing Architecture</title>

      <para>Now that you're familiar with using PHOCOA and WFModule to build
      web pages, you should be excited to know that all of the pages in each
      <classname>WFModule</classname> you create is automatically a reusable
      component.</para>

      <para>Let's say you've built a simple module/page that displays links to
      the 10 most recent blog posts on your site. Now of course this is an
      excellent web page, but it'd also be great to include the same list
      inside other pages.</para>

      <para>This is easily accomplished with the
      <classname>WFModuleView</classname> widget. This widget simply includes
      the output of the specified module/page as a "snippet" of HTML code that
      appears in another page. When you include a module/page with
      <classname>WFModuleView</classname>, PHOCOA knows automatically that the
      component will be used as a snippet, so the HTML code will not be
      skinned.</para>

      <para>To include another module as a subcomponent, simply create a
      <classname>WFModuleView</classname> instance and set the
      <property>invocationPath</property> property to the desired
      subcomponent:</para>

      <programlisting>// in your page's PageDidLoad method
$recent10 = new WFModuleView('recent10', $page);
$recent10-&gt;setInvocationPath('blog/list/recent/10')

// in your page's tpl file
&lt;p&gt;10 Most Recent Posts&lt;/p&gt;
&lt;div&gt;{WFModuleView id="recent10"}&lt;/div&gt;</programlisting>

      <para>As you can see, re-using module/page components couldn't be
      easier.</para>
    </section>

    <section>
      <title>Skin / Template System</title>

      <para>PHOCOA's skin system provides a simple yet flexible way to control
      the template being used to render each page. The skin system has three
      layers:</para>

      <para><itemizedlist>
          <listitem>
            <para><emphasis>Skin Type (Skin Delegate) </emphasis>At the top
            level is the Skin Type. Each skin type can have its own distinct
            infrastructure of common components, which are managed by its Skin
            Delegate. The skin type is not a layout in and of itself; rather
            it is just an implementation of the layout from a semantic
            perspective. The Skin Delegate provides an interface for the skins
            (explained below) to access the data common to the layout. An
            example of a skin type would be an "Admin" interface and a
            "Public" interface for an application.</para>
          </listitem>

          <listitem>
            <para><emphasis>Skin</emphasis> Each skin is a concrete
            implementation of an actual layout. There can be any number of
            skins that implement layouts for each Skin Type.</para>
          </listitem>

          <listitem>
            <para><emphasis>Template Type</emphasis> Each skin by default has
            just one template file, template_normal.tpl. If you want minor
            variations of the same look and feel, such as for a popup or
            mobile version, this is the way to do it. Different template types
            of the same skin will still be "themed".</para>
          </listitem>

          <listitem>
            <para><emphasis>Skin Theme</emphasis> Each skin is further
            subdivided, optionally, into themes. Themes provide an easy way to
            use the same basic layout (the Skin) while changing colorschemes,
            graphics packages, etc.</para>
          </listitem>
        </itemizedlist>By default, a new PHOCOA application has a single Skin
      Type (simple) and two Skins (simple1, simple2). Simple1 has only one
      theme, while simple2 has two themes set up.</para>

      <para>The bundled "SkinInfo" module provides an interactive browser for
      the installed skins on any PHOCOA application to make it easy to
      understand and browse the skin infrastructure. This is also available at
      http://phococa.com/examples/skinInfo.</para>

      <bridgehead>Determining When To Use The Various Aspects of the Skin
      System</bridgehead>

      <para>How do you know when you should create a new skin type, or just a
      new skin, or just a new skin theme? Here are a few pointers:</para>

      <itemizedlist>
        <listitem>
          <para>If you just want a slight variation on an existing look and
          feel (i.e., different header graphics, different colors), then you
          should use make a skin theme for each variation.</para>
        </listitem>

        <listitem>
          <para>If you are keeping the same look and feel, but want a slightly
          different layout (maybe for a pop-up window or a mobile version),
          then you should make a new templateType for your skin.</para>
        </listitem>

        <listitem>
          <para>If you want a different look and feel, but need to display all
          of the same elements on the page, you should create a new
          skin.</para>
        </listitem>

        <listitem>
          <para>If you need to represent an entirely different set of elements
          on the web page, such as for an admin interface vs. the public
          interface, then you should create a new skin type.</para>
        </listitem>
      </itemizedlist>

      <para>Most applications will have a single skin type, and a single skin,
      with one or more thems, and maybe a few extra template types. Don't get
      too overwhelmed with the options. The flexibility in the skin system is
      primarily intended for CMS applications or large web applications with
      multiple "sections".</para>
    </section>

    <section>
      <title>Setting HTML Top-Level Attributes</title>

      <para>It is a best-practice to set up the Title, Meta Keywords, and Meta
      Description of each page to keep the information relevant and help with
      search engine optimization, as well as providing user-friendly web page
      titles for history navigation. PHOCOA provides a callback mechanism on a
      page-by-page basis to allow you to edit this information.</para>

      <para>Often times you'll also need to include additional head elements
      like SCRIPT and CSS files.</para>

      <para>The prototype of the callback is:</para>

      <programlisting>function &lt;pageName&gt;_SkinSetup($skin)</programlisting>

      <para>The function should be implemented in your WFModule subclass. Here
      is an example:</para>

      <programlisting>    function helloWorld_SetupSkin($skin)
    {   
        $skin-&gt;setTitle("Hello, World, from PHOCOA!");
        $skin-&gt;addMetaKeywords(array('keyword 1', 'keyword 2'));
        $skin-&gt;setMetaDescription('Hello world example module in PHOCOA.');
        $skin-&gt;addHeadString('&lt;script type="text/javascript" src="/webapp/www/js/myJSFile.js"&gt;&lt;/script&gt;');
    }</programlisting>
    </section>

    <section>
      <title>Security / Authentication</title>

      <para>PHOCOA includes a simple yet extensible security architecture.
      PHOCOA's WFAuthorizationManager is in charge of coordinating security
      and authentication.</para>

      <para>PHOCOA maintains a session object which is an instance of
      <classname>WFAuthorizationInfo</classname>. This class contains basic
      information about the currently logged in user (if there is one), such
      as the user's id, is the user a "super-user", has the user authenticated
      "recently", etc. This is enough information for most applications, but
      if you have more complicated access control, you can subclass
      <classname>WFAuthorizationInfo</classname> and add any information you
      need for your system.</para>

      <para>The basic granularity of security is at the module level. This
      assumption is made since modules typically include related pages which
      share the same access restrictions. Thus, usually a user that can access
      one page in a module should be able to access all others.</para>

      <para>Access control to a module is determined by the
      <function>checkSecurity</function> method. The default implementation
      allows unrestricted access. To secure access to a module, you simply
      override the <function>checkSecurity</function> method in your WFModule
      subclass. The only parameter to this function is the current
      <classname>WFAuthorizationInfo</classname> instance, and you return
      either <classname>WFAuthorizationManager::ALLOW</classname> or
      <classname>WFAuthorizationManager::DENY</classname>. You can use
      whatever logic you want to in this method to determine access
      rights.</para>

      <para><programlisting>function checkSecurity (WFAuthorizationInfo $authInfo)
{
    if ($authInfo-&gt;isSuperUser()) return WFAuthorizationManager::ALLOW;
    return WFAuthorizationManager::DENY;
}</programlisting>Of course, data security also is important at the object
      level. For instance, a logged-in customer should only be able to edit
      his own record. To implement security at this level, the programmer
      should check the credentials of the logged in user against the data
      being edited. If the logged in user should be denied access, this can be
      done simply by throwing a
      <classname>WFAuthorizationException</classname>.</para>

      <para>PHOCOA automatically handles logins. When a client attempts to
      access a module, and the <classname>checkSecurity</classname> method
      returns <classname>DENY</classname>, PHOCOA will automatically handle
      the situation. If the user is already logged in, they will be shown an
      "Access Denied" message. If there is no logged in user, the client will
      be redirected to the login page, and upon successful login, will be
      redirected back to the original request.</para>

      <para>PHOCOA's login system handles all of the details of login except
      for determining if a given user/pass is valid, and setting up the
      "permissions" for the user. Your application need only supply PHOCOA
      with a <classname>WFAuthorizationDelegate</classname> instance to
      provide that functionality.</para>

      <para>Your application tells PHOCOA which
      <classname>WFAuthorizationDelegate</classname> to use. We recommend that
      you do this in the <function>WFWebApplication::initialize()</function>
      delegate method. The <classname>WFAuthorizationDelegate</classname>
      contains only one method:</para>

      <programlisting>object WFAuthorizationInfo login (string $username, string $password, boolean $passIsToken)</programlisting>

      <para>All this function needs to do is determine whether or not the
      username/password combo is valid, and then create a WFAuthorizationInfo
      instance for the user's session. Notice the
      <varname>$passIsToken</varname> parameter; this is used for a "Remember
      me" feature. If the user chooses to preserve his login info on his
      computer, and the session times out, PHOCOA will automatically try to
      log in the user again with a stored token. If this parameter is true,
      the password will be a hash of the password stored in the user's cookie
      rather than the actual password.</para>

      <note>
        <para>If you think need to use multiple delegates in your application,
        we recommend that set a different <function>php_ini</function>
        "session.name" for each delegate type. Since PHOCOA stores the
        <classname>WFAuthorizationInfo</classname> instance in a session, it
        is important to ensure that the proper instance is recalled for the
        current request.</para>
      </note>
    </section>

    <section>
      <title>PHOCOA API Documentation</title>

      <para>The complete PHOCOA documentation is available online at <ulink
      url="http://phocoa.com/docs">http://phocoa.com/docs/</ulink>.</para>
    </section>

    <section>
      <title>Further Explorations</title>

      <bridgehead>PHOCOA Key-Value Coding and Bindings Primer</bridgehead>

      <para>PHOCOA bindings make it easy to show information from your
      Key-Value Coding Compliant objects, which includes Propel objects if
      you've implemented the Propel changes noted in the appendix.</para>

      <para>You can use WFObject's valueForKeyPath() function to access
      properties of your objects. For instance, if you have a Book object, and
      want to access the birthdate of the author, you could use:</para>

      <screen>$authorBirthDate = $book-&gt;valueForKeyPath("author.birthDate");</screen>

      <para>Which is equivalent to:</para>

      <screen>$authorBirthDate = $book-&gt;getAuthor()-&gt;getBirthDate();</screen>

      <para>While it doesn't seem that advantageous from just looking at the
      code, it becomes much more powerful when coupled with PHOCOA
      bindings.</para>

      <para>Let's say you want to have a web page that shows the details of a
      book. Normally, you'd have to assign the $book object to your template
      engine and then put something like
      {$book-&gt;getAuthor()-&gt;getBirthDate()} in your template code.</para>

      <para>With PHOCOA, instead of assigning the $book object to your
      template, you instead make the $book object one of the instance
      variables of your module. Then, you set up a WFLabel object and bind the
      "value" of the WFLabel to the $book variable, and set a keyPath of
      "author.birthDate" as the modelKeyPath.</para>

      <para>Now, even this doesn't seem that different. However, as you might
      be starting to notice, the keyPath for the WFLabel object isn't
      <emphasis>programming</emphasis>, it's
      <emphasis>configuration</emphasis>. So, if you want to change the value
      of the label, you just edit the configuration of the keyPath and the new
      value will be used.</para>

      <para>Furthermore, because you're using PHOCOA GUI widgets, you get
      access to a host of additional functionality without having to add any
      code. Want to truncate the string after 30 characters? Just configure
      the "ellipsisAfterChars" property of the label. Want to hide the label
      in certain circumstances? Just bind the "hidden" property of the WFLabel
      to a function returning a boolean value and PHOCOA does the rest. Want
      the birthdate to show up as a properly formatted date? Just provide a
      formatter to the WFLabel. Want to use a formatString to combine multiple
      values? Use the ValuePattern binding! This is all done via the
      configuration file, not via coding.</para>
    </section>

    <section>
      <title>Further Resources</title>

      <para>Visit <ulink url="http://phocoa.com">http://phocoa.com</ulink> for
      the latest news, downloads, etc. There are also a mailing lists that you
      can join at <ulink
      url="http://lists.phocoa.com">http://lists.phocoa.com</ulink>.</para>
    </section>

    <section>
      <title>Conclusion</title>

      <para>Hopefully this brief tutorial has showed to you the benefits of
      PHOCOA development, and taught you enough to experiment on your own.
      Thanks for reading!</para>
    </section>

    <section>
      <title>Appendix A: Dependencies</title>

      <para><itemizedlist>
          <listitem>
            <para>PHP5 - PHOCOA requires PHP version 5.0.</para>
          </listitem>

          <listitem>
            <para>PEAR::Log - Required.</para>
          </listitem>

          <listitem>
            <para>PEAR::Mail + PEAR::Mail_Mime - Optional; needed to use the
            included Mail_Mailer class.</para>
          </listitem>

          <listitem>
            <para>Phing - PHP build system. Required.</para>
          </listitem>

          <listitem>
            <para>Propel - not required, but certainly recommended if you're
            building a database-driven project. You can use whatever ORM you
            like as long as the classes can set WFObject as the base
            class.</para>
          </listitem>
        </itemizedlist>That's all the current dependencies.</para>
    </section>

    <section>
      <title>Appendix B: Using PHOCOA With Propel</title>

      <para>PHOCOA is designed to use Propel as an analog for Core Data. By
      making a 2-line change to the Propel code, your Propel objects will
      automatically be Key-Value Coding compliant, making it very simple to
      make your PHOCOA application interact with Propel.</para>

      <para>To update your Propel to work with Phocoa, simply edit the
      propel/om/BaseObject.php file in 2 places:</para>

      <para><orderedlist>
          <listitem>
            <para>Make the Propel BaseObject a subclass of the PHOCOA WFObject
            base class:</para>

            <screen>abstract class BaseObject<emphasis> extends WFObject </emphasis>{</screen>
          </listitem>
        </orderedlist></para>

      <para>That's it! Your Propel install is now fully compatible with PHOCOA
      to act as the data store for your objects.</para>
    </section>

    <glossary>
      <glossdiv>
        <title>Glossary</title>

        <glossentry>
          <glossterm>phing</glossterm>

          <glossdef>
            <para>A build system for php based on ant. See <ulink
            url="http://phing.info">http://phing.info</ulink></para>
          </glossdef>
        </glossentry>
      </glossdiv>
    </glossary>
  </chapter>
</book>